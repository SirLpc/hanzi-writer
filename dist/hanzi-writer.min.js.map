{"version":3,"file":"hanzi-writer.min.js","sources":["../src/utils.ts","../src/RenderState.ts","../src/geometry.ts","../src/models/Stroke.ts","../src/models/Character.ts","../src/parseCharData.ts","../src/Positioner.ts","../src/strokeMatches.ts","../src/models/UserStroke.ts","../src/Mutation.ts","../src/characterActions.ts","../src/quizActions.ts","../src/Quiz.ts","../src/renderers/svg/svgUtils.ts","../src/renderers/StrokeRendererBase.ts","../src/renderers/svg/StrokeRenderer.ts","../src/renderers/svg/CharacterRenderer.ts","../src/renderers/svg/UserStrokeRenderer.ts","../src/renderers/RenderTargetBase.ts","../src/renderers/svg/RenderTarget.ts","../src/renderers/svg/index.ts","../src/renderers/svg/HanziWriterRenderer.ts","../src/renderers/canvas/canvasUtils.ts","../src/renderers/canvas/StrokeRenderer.ts","../src/renderers/canvas/CharacterRenderer.ts","../src/renderers/canvas/renderUserStroke.ts","../src/renderers/canvas/RenderTarget.ts","../src/renderers/canvas/index.ts","../src/renderers/canvas/HanziWriterRenderer.ts","../src/defaultCharDataLoader.ts","../src/defaultOptions.ts","../src/LoadingManager.ts","../src/HanziWriter.ts"],"sourcesContent":["import { ColorObject, RecursivePartial } from './typings/types';\r\n\r\n// hacky way to get around rollup not properly setting `global` to `window` in browser\r\nconst globalObj = typeof window === 'undefined' ? global : window;\r\n\r\nexport const performanceNow =\r\n  (globalObj.performance && (() => globalObj.performance.now())) || (() => Date.now());\r\nexport const requestAnimationFrame =\r\n  globalObj.requestAnimationFrame ||\r\n  ((callback) => setTimeout(() => callback(performanceNow()), 1000 / 60));\r\nexport const cancelAnimationFrame = globalObj.cancelAnimationFrame || clearTimeout;\r\n\r\n// Object.assign polyfill, because IE :/\r\nexport const _assign = function (target: any, ...overrides: any[]) {\r\n  const overrideTarget = Object(target);\r\n  overrides.forEach((override) => {\r\n    if (override != null) {\r\n      for (const key in override) {\r\n        if (Object.prototype.hasOwnProperty.call(override, key)) {\r\n          overrideTarget[key] = override[key];\r\n        }\r\n      }\r\n    }\r\n  });\r\n  return overrideTarget;\r\n};\r\n\r\nexport const assign = Object.assign || _assign;\r\n\r\nexport function arrLast<TValue>(arr: Array<TValue>) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nexport const fixIndex = (index: number, length: number) => {\r\n  // helper to handle negative indexes in array indices\r\n  if (index < 0) {\r\n    return length + index;\r\n  }\r\n  return index;\r\n};\r\n\r\nexport const selectIndex = <T>(arr: Array<T>, index: number) => {\r\n  // helper to select item from array at index, supporting negative indexes\r\n  return arr[fixIndex(index, arr.length)];\r\n};\r\n\r\nexport function copyAndMergeDeep<T>(base: T, override: RecursivePartial<T> | undefined) {\r\n  const output = { ...base };\r\n  for (const key in override) {\r\n    const baseVal = base[key];\r\n    const overrideVal = override[key];\r\n    if (baseVal === overrideVal) {\r\n      continue;\r\n    }\r\n    if (\r\n      baseVal &&\r\n      overrideVal &&\r\n      typeof baseVal === 'object' &&\r\n      typeof overrideVal === 'object' &&\r\n      !Array.isArray(overrideVal)\r\n    ) {\r\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\r\n    } else {\r\n      // @ts-ignore\r\n      output[key] = overrideVal;\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\r\nexport function inflate(scope: string, obj: any): any {\r\n  const parts = scope.split('.');\r\n  const final: any = {};\r\n  let current = final;\r\n  for (let i = 0; i < parts.length; i++) {\r\n    const cap = i === parts.length - 1 ? obj : {};\r\n    current[parts[i]] = cap;\r\n    current = cap;\r\n  }\r\n  return final;\r\n}\r\n\r\nlet count = 0;\r\n\r\nexport function counter() {\r\n  count++;\r\n  return count;\r\n}\r\n\r\nexport function average(arr: number[]) {\r\n  const sum = arr.reduce((acc, val) => val + acc, 0);\r\n  return sum / arr.length;\r\n}\r\n\r\nexport function timeout(duration = 0) {\r\n  return new Promise((resolve) => setTimeout(resolve, duration));\r\n}\r\n\r\nexport function colorStringToVals(colorString: string): ColorObject {\r\n  const normalizedColor = colorString.toUpperCase().trim();\r\n  // based on https://stackoverflow.com/a/21648508\r\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\r\n    let hexParts = normalizedColor.substring(1).split('');\r\n    if (hexParts.length === 3) {\r\n      hexParts = [\r\n        hexParts[0],\r\n        hexParts[0],\r\n        hexParts[1],\r\n        hexParts[1],\r\n        hexParts[2],\r\n        hexParts[2],\r\n      ];\r\n    }\r\n    const hexStr = `${hexParts.join('')}`;\r\n    return {\r\n      r: parseInt(hexStr.slice(0, 2), 16),\r\n      g: parseInt(hexStr.slice(2, 4), 16),\r\n      b: parseInt(hexStr.slice(4, 6), 16),\r\n      a: 1,\r\n    };\r\n  }\r\n  const rgbMatch = normalizedColor.match(\r\n    /^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/,\r\n  );\r\n  if (rgbMatch) {\r\n    return {\r\n      r: parseInt(rgbMatch[1], 10),\r\n      g: parseInt(rgbMatch[2], 10),\r\n      b: parseInt(rgbMatch[3], 10),\r\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\r\n      a: parseFloat(rgbMatch[4] || 1, 10),\r\n    };\r\n  }\r\n  throw new Error(`Invalid color: ${colorString}`);\r\n}\r\n\r\nexport const trim = (string: string) => string.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\r\n// return a new array-like object with int keys where each key is item\r\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\r\nexport function objRepeat<T>(item: T, times: number) {\r\n  const obj: Record<number, T> = {};\r\n  for (let i = 0; i < times; i++) {\r\n    obj[i] = item;\r\n  }\r\n  return obj;\r\n}\r\n\r\n// similar to objRepeat, but takes in a callback which is called for each index in the object\r\nexport function objRepeatCb<T>(times: number, cb: (i: number) => T) {\r\n  const obj: Record<number, T> = {};\r\n  for (let i = 0; i < times; i++) {\r\n    obj[i] = cb(i);\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst ua = globalObj.navigator?.userAgent || '';\r\n\r\nexport const isMsBrowser =\r\n  ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nexport const noop = () => {};\r\n","import Character from './models/Character';\r\nimport { GenericMutation } from './Mutation';\r\nimport {\r\n  ColorObject,\r\n  OnCompleteFunction,\r\n  Point,\r\n  RecursivePartial,\r\n} from './typings/types';\r\nimport { copyAndMergeDeep, colorStringToVals, noop } from './utils';\r\n\r\nexport type StrokeRenderState = {\r\n  opacity: number;\r\n  displayPortion: number;\r\n};\r\n\r\nexport type CharacterRenderState = {\r\n  opacity: number;\r\n  strokes: Record<number | string, StrokeRenderState>;\r\n};\r\n\r\nexport type RenderStateObject = {\r\n  options: {\r\n    drawingFadeDuration: number;\r\n    drawingWidth: number;\r\n    drawingColor: ColorObject;\r\n    strokeColor: ColorObject;\r\n    outlineColor: ColorObject;\r\n    radicalColor: ColorObject;\r\n    highlightColor: ColorObject;\r\n  };\r\n  character: {\r\n    main: CharacterRenderState;\r\n    outline: CharacterRenderState;\r\n    highlight: CharacterRenderState;\r\n  };\r\n  userStrokes: Record<\r\n    string,\r\n    | {\r\n        points: Point[];\r\n        opacity: number;\r\n      }\r\n    | undefined\r\n  > | null;\r\n};\r\n\r\nexport type CharacterName = keyof RenderStateObject['character'];\r\n\r\ntype OnStateChangeCallback = (\r\n  nextState: RenderStateObject,\r\n  currentState: RenderStateObject,\r\n) => void;\r\n\r\ntype MutationChain = {\r\n  _isActive: boolean;\r\n  _index: number;\r\n  _resolve: OnCompleteFunction;\r\n  _mutations: GenericMutation[];\r\n  _loop: boolean | undefined;\r\n  _scopes: string[];\r\n};\r\n\r\nexport type RenderStateOptions = {\r\n  strokeColor: string;\r\n  radicalColor: string | null;\r\n  highlightColor: string;\r\n  outlineColor: string;\r\n  drawingColor: string;\r\n  drawingFadeDuration: number;\r\n  drawingWidth: number;\r\n  outlineWidth: number;\r\n  showCharacter: boolean;\r\n  showOutline: boolean;\r\n};\r\n\r\nexport default class RenderState {\r\n  _mutationChains: MutationChain[] = [];\r\n  _onStateChange: OnStateChangeCallback;\r\n\r\n  state: RenderStateObject;\r\n\r\n  constructor(\r\n    character: Character,\r\n    options: RenderStateOptions,\r\n    onStateChange: OnStateChangeCallback = noop,\r\n  ) {\r\n    this._onStateChange = onStateChange;\r\n\r\n    this.state = {\r\n      options: {\r\n        drawingFadeDuration: options.drawingFadeDuration,\r\n        drawingWidth: options.drawingWidth,\r\n        drawingColor: colorStringToVals(options.drawingColor),\r\n        strokeColor: colorStringToVals(options.strokeColor),\r\n        outlineColor: colorStringToVals(options.outlineColor),\r\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\r\n        highlightColor: colorStringToVals(options.highlightColor),\r\n      },\r\n      character: {\r\n        main: {\r\n          opacity: options.showCharacter ? 1 : 0,\r\n          strokes: {},\r\n        },\r\n        outline: {\r\n          opacity: options.showOutline ? 1 : 0,\r\n          strokes: {},\r\n        },\r\n        highlight: {\r\n          opacity: 1,\r\n          strokes: {},\r\n        },\r\n      },\r\n      userStrokes: null,\r\n    };\r\n\r\n    for (let i = 0; i < character.strokes.length; i++) {\r\n      this.state.character.main.strokes[i] = {\r\n        opacity: 1,\r\n        displayPortion: 1,\r\n      };\r\n\r\n      this.state.character.outline.strokes[i] = {\r\n        opacity: 1,\r\n        displayPortion: 1,\r\n      };\r\n\r\n      this.state.character.highlight.strokes[i] = {\r\n        opacity: 0,\r\n        displayPortion: 1,\r\n      };\r\n    }\r\n  }\r\n\r\n  overwriteOnStateChange(onStateChange: OnStateChangeCallback) {\r\n    this._onStateChange = onStateChange;\r\n  }\r\n\r\n  updateState(stateChanges: RecursivePartial<RenderStateObject>) {\r\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\r\n    this._onStateChange(nextState, this.state);\r\n    this.state = nextState;\r\n  }\r\n\r\n  run(\r\n    mutations: GenericMutation[],\r\n    options: {\r\n      loop?: boolean;\r\n    } = {},\r\n  ) {\r\n    const scopes = mutations.map((mut) => mut.scope);\r\n\r\n    this.cancelMutations(scopes);\r\n\r\n    return new Promise((resolve: OnCompleteFunction) => {\r\n      const mutationChain: MutationChain = {\r\n        _isActive: true,\r\n        _index: 0,\r\n        _resolve: resolve,\r\n        _mutations: mutations,\r\n        _loop: options.loop,\r\n        _scopes: scopes,\r\n      };\r\n      this._mutationChains.push(mutationChain);\r\n      this._run(mutationChain);\r\n    });\r\n  }\r\n\r\n  _run(mutationChain: MutationChain) {\r\n    if (!mutationChain._isActive) {\r\n      return;\r\n    }\r\n\r\n    const mutations = mutationChain._mutations;\r\n    if (mutationChain._index >= mutations.length) {\r\n      if (mutationChain._loop) {\r\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\r\n      } else {\r\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\r\n        this._mutationChains = this._mutationChains.filter(\r\n          (chain) => chain !== mutationChain,\r\n        );\r\n        // The chain is done - resolve the promise to signal it finished successfully\r\n        mutationChain._resolve({ canceled: false });\r\n        return;\r\n      }\r\n    }\r\n\r\n    const activeMutation = mutationChain._mutations[mutationChain._index];\r\n\r\n    activeMutation.run(this).then(() => {\r\n      if (mutationChain._isActive) {\r\n        mutationChain._index++; // eslint-disable-line no-param-reassign\r\n        this._run(mutationChain);\r\n      }\r\n    });\r\n  }\r\n\r\n  _getActiveMutations() {\r\n    return this._mutationChains.map((chain) => chain._mutations[chain._index]);\r\n  }\r\n\r\n  pauseAll() {\r\n    this._getActiveMutations().forEach((mutation) => mutation.pause());\r\n  }\r\n\r\n  resumeAll() {\r\n    this._getActiveMutations().forEach((mutation) => mutation.resume());\r\n  }\r\n\r\n  cancelMutations(scopesToCancel: string[]) {\r\n    for (const chain of this._mutationChains) {\r\n      for (const chainId of chain._scopes) {\r\n        for (const scopeToCancel of scopesToCancel) {\r\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\r\n            this._cancelMutationChain(chain);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  cancelAll() {\r\n    this.cancelMutations(['']);\r\n  }\r\n\r\n  _cancelMutationChain(mutationChain: MutationChain) {\r\n    mutationChain._isActive = false;\r\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\r\n      mutationChain._mutations[i].cancel(this);\r\n    }\r\n\r\n    mutationChain._resolve?.({ canceled: true });\r\n\r\n    this._mutationChains = this._mutationChains.filter(\r\n      (chain) => chain !== mutationChain,\r\n    );\r\n  }\r\n}\r\n","import { Point } from './typings/types';\r\nimport { average, arrLast } from './utils';\r\n\r\nexport const subtract = (p1: Point, p2: Point) => ({ x: p1.x - p2.x, y: p1.y - p2.y });\r\n\r\nexport const magnitude = (point: Point) =>\r\n  Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\r\n\r\nexport const distance = (point1: Point, point2: Point) =>\r\n  magnitude(subtract(point1, point2));\r\n\r\nexport const equals = (point1: Point, point2: Point) =>\r\n  point1.x === point2.x && point1.y === point2.y;\r\n\r\nexport const round = (point: Point, precision = 1) => {\r\n  const multiplier = precision * 10;\r\n  return {\r\n    x: Math.round(multiplier * point.x) / multiplier,\r\n    y: Math.round(multiplier * point.y) / multiplier,\r\n  };\r\n};\r\n\r\nexport const length = (points: Point[]) => {\r\n  let lastPoint = points[0];\r\n  const pointsSansFirst = points.slice(1);\r\n  return pointsSansFirst.reduce((acc, point) => {\r\n    const dist = distance(point, lastPoint);\r\n    lastPoint = point;\r\n    return acc + dist;\r\n  }, 0);\r\n};\r\n\r\nexport const cosineSimilarity = (point1: Point, point2: Point) => {\r\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\r\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\r\n};\r\n\r\n/**\r\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\r\n * from p2. p1, p2, p3 will always lie on the line in that order\r\n */\r\nexport const _extendPointOnLine = (p1: Point, p2: Point, dist: number) => {\r\n  const vect = subtract(p2, p1);\r\n  const norm = dist / magnitude(vect);\r\n  return { x: p2.x + norm * vect.x, y: p2.y + norm * vect.y };\r\n};\r\n\r\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\r\nexport const frechetDist = (curve1: Point[], curve2: Point[]) => {\r\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\r\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\r\n\r\n  const calcVal = (\r\n    i: number,\r\n    j: number,\r\n    prevResultsCol: number[],\r\n    curResultsCol: number[],\r\n  ): number => {\r\n    if (i === 0 && j === 0) {\r\n      return distance(longCurve[0], shortCurve[0]);\r\n    }\r\n\r\n    if (i > 0 && j === 0) {\r\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\r\n    }\r\n\r\n    const lastResult = curResultsCol[curResultsCol.length - 1];\r\n\r\n    if (i === 0 && j > 0) {\r\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\r\n    }\r\n\r\n    return Math.max(\r\n      Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult),\r\n      distance(longCurve[i], shortCurve[j]),\r\n    );\r\n  };\r\n\r\n  let prevResultsCol: number[] = [];\r\n  for (let i = 0; i < longCurve.length; i++) {\r\n    const curResultsCol: number[] = [];\r\n    for (let j = 0; j < shortCurve.length; j++) {\r\n      // we only need the results from i - 1 and j - 1 to continue the calculation\r\n      // so we only need to hold onto the last column of calculated results\r\n      // prevResultsCol is results[i-1][:] in the original algorithm\r\n      // curResultsCol is results[i][:j-1] in the original algorithm\r\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\r\n    }\r\n    prevResultsCol = curResultsCol;\r\n  }\r\n\r\n  return prevResultsCol[shortCurve.length - 1];\r\n};\r\n\r\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\r\nexport const subdivideCurve = (curve: Point[], maxLen = 0.05) => {\r\n  const newCurve = curve.slice(0, 1);\r\n\r\n  for (const point of curve.slice(1)) {\r\n    const prevPoint = newCurve[newCurve.length - 1];\r\n    const segLen = distance(point, prevPoint);\r\n    if (segLen > maxLen) {\r\n      const numNewPoints = Math.ceil(segLen / maxLen);\r\n      const newSegLen = segLen / numNewPoints;\r\n      for (let i = 0; i < numNewPoints; i++) {\r\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\r\n      }\r\n    } else {\r\n      newCurve.push(point);\r\n    }\r\n  }\r\n\r\n  return newCurve;\r\n};\r\n\r\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\r\nexport const outlineCurve = (curve: Point[], numPoints = 30) => {\r\n  const curveLen = length(curve);\r\n  const segmentLen = curveLen / (numPoints - 1);\r\n  const outlinePoints = [curve[0]];\r\n  const endPoint = arrLast(curve);\r\n  const remainingCurvePoints = curve.slice(1);\r\n\r\n  for (let i = 0; i < numPoints - 2; i++) {\r\n    let lastPoint: Point = arrLast(outlinePoints);\r\n    let remainingDist = segmentLen;\r\n    let outlinePointFound = false;\r\n    while (!outlinePointFound) {\r\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\r\n      if (nextPointDist < remainingDist) {\r\n        remainingDist -= nextPointDist;\r\n        lastPoint = remainingCurvePoints.shift()!;\r\n      } else {\r\n        const nextPoint = _extendPointOnLine(\r\n          lastPoint,\r\n          remainingCurvePoints[0],\r\n          remainingDist - nextPointDist,\r\n        );\r\n        outlinePoints.push(nextPoint);\r\n        outlinePointFound = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  outlinePoints.push(endPoint);\r\n\r\n  return outlinePoints;\r\n};\r\n\r\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\r\nexport const normalizeCurve = (curve: Point[]) => {\r\n  const outlinedCurve = outlineCurve(curve);\r\n  const meanX = average(outlinedCurve.map((point) => point.x));\r\n  const meanY = average(outlinedCurve.map((point) => point.y));\r\n  const mean = { x: meanX, y: meanY };\r\n  const translatedCurve = outlinedCurve.map((point) => subtract(point, mean));\r\n  const scale = Math.sqrt(\r\n    average([\r\n      Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2),\r\n      Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2),\r\n    ]),\r\n  );\r\n  const scaledCurve = translatedCurve.map((point) => ({\r\n    x: point.x / scale,\r\n    y: point.y / scale,\r\n  }));\r\n  return subdivideCurve(scaledCurve);\r\n};\r\n\r\n// rotate around the origin\r\nexport const rotate = (curve: Point[], theta: number) => {\r\n  return curve.map((point) => ({\r\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\r\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y,\r\n  }));\r\n};\r\n\r\n// remove intermediate points that are on the same line as the points to either side\r\nexport const _filterParallelPoints = (points: Point[]) => {\r\n  if (points.length < 3) return points;\r\n  const filteredPoints = [points[0], points[1]];\r\n  points.slice(2).forEach((point) => {\r\n    const numFilteredPoints = filteredPoints.length;\r\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\r\n    const prevVect = subtract(\r\n      filteredPoints[numFilteredPoints - 1],\r\n      filteredPoints[numFilteredPoints - 2],\r\n    );\r\n    // this is the z coord of the cross-product. If this is 0 then they're parallel\r\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\r\n    if (isParallel) {\r\n      filteredPoints.pop();\r\n    }\r\n    filteredPoints.push(point);\r\n  });\r\n  return filteredPoints;\r\n};\r\n\r\nexport function getPathString(points: Point[], close = false) {\r\n  const start = round(points[0]);\r\n  const remainingPoints = points.slice(1);\r\n  let pathString = `M ${start.x} ${start.y}`;\r\n  remainingPoints.forEach((point) => {\r\n    const roundedPoint = round(point);\r\n    pathString += ` L ${roundedPoint.x} ${roundedPoint.y}`;\r\n  });\r\n  if (close) {\r\n    pathString += 'Z';\r\n  }\r\n  return pathString;\r\n}\r\n\r\n/** take points on a path and move their start point backwards by distance */\r\nexport const extendStart = (points: Point[], dist: number) => {\r\n  const filteredPoints = _filterParallelPoints(points);\r\n  if (filteredPoints.length < 2) return filteredPoints;\r\n  const p1 = filteredPoints[1];\r\n  const p2 = filteredPoints[0];\r\n  const newStart = _extendPointOnLine(p1, p2, dist);\r\n  const extendedPoints = filteredPoints.slice(1);\r\n  extendedPoints.unshift(newStart);\r\n  return extendedPoints;\r\n};\r\n","import { subtract, distance, length } from '../geometry';\r\nimport { Point } from '../typings/types';\r\n\r\nexport default class Stroke {\r\n  path: string;\r\n  points: Point[];\r\n  strokeNum: number;\r\n  isInRadical: boolean;\r\n\r\n  constructor(path: string, points: Point[], strokeNum: number, isInRadical = false) {\r\n    this.path = path;\r\n    this.points = points;\r\n    this.strokeNum = strokeNum;\r\n    this.isInRadical = isInRadical;\r\n  }\r\n\r\n  getStartingPoint() {\r\n    return this.points[0];\r\n  }\r\n\r\n  getEndingPoint() {\r\n    return this.points[this.points.length - 1];\r\n  }\r\n\r\n  getLength(): number {\r\n    return length(this.points);\r\n  }\r\n\r\n  getVectors() {\r\n    let lastPoint = this.points[0];\r\n    const pointsSansFirst = this.points.slice(1);\r\n    return pointsSansFirst.map((point) => {\r\n      const vector = subtract(point, lastPoint);\r\n      lastPoint = point;\r\n      return vector;\r\n    });\r\n  }\r\n\r\n  getDistance(point: Point) {\r\n    const distances = this.points.map((strokePoint) => distance(strokePoint, point));\r\n    return Math.min(...distances);\r\n  }\r\n\r\n  getAverageDistance(points: Point[]) {\r\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\r\n    return totalDist / points.length;\r\n  }\r\n}\r\n","import Stroke from './Stroke';\r\n\r\nexport default class Character {\r\n  symbol: string;\r\n  strokes: Stroke[];\r\n\r\n  constructor(symbol: string, strokes: Stroke[]) {\r\n    this.symbol = symbol;\r\n    this.strokes = strokes;\r\n  }\r\n}\r\n","import Stroke from './models/Stroke';\r\nimport Character from './models/Character';\r\nimport { CharacterJson } from './typings/types';\r\n\r\nfunction generateStrokes({ radStrokes, strokes, medians }: CharacterJson) {\r\n  const isInRadical = (strokeNum: number) => (radStrokes?.indexOf(strokeNum) ?? -1) >= 0;\r\n  return strokes.map((path, index) => {\r\n    const points = medians[index].map((pointData) => {\r\n      const [x, y] = pointData;\r\n      return { x, y };\r\n    });\r\n    return new Stroke(path, points, index, isInRadical(index));\r\n  });\r\n}\r\n\r\nexport default function parseCharData(symbol: string, charJson: CharacterJson) {\r\n  const strokes = generateStrokes(charJson);\r\n  return new Character(symbol, strokes);\r\n}\r\n","import { Point } from './typings/types';\r\n\r\n// All makemeahanzi characters have the same bounding box\r\nconst CHARACTER_BOUNDS = [\r\n  { x: 0, y: -124 },\r\n  { x: 1024, y: 900 },\r\n];\r\nconst [from, to] = CHARACTER_BOUNDS;\r\nconst preScaledWidth = to.x - from.x;\r\nconst preScaledHeight = to.y - from.y;\r\n\r\nexport type PositionerOptions = {\r\n  /** Default: 0 */\r\n  width: number;\r\n  /** Default: 0 */\r\n  height: number;\r\n  /** Default: 20 */\r\n  padding: number;\r\n};\r\n\r\nexport default class Positioner {\r\n  padding: number;\r\n  width: number;\r\n  height: number;\r\n  xOffset: number;\r\n  yOffset: number;\r\n  scale: number;\r\n\r\n  constructor(options: PositionerOptions) {\r\n    const { padding, width, height } = options;\r\n    this.padding = padding;\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    const effectiveWidth = width - 2 * padding;\r\n    const effectiveHeight = height - 2 * padding;\r\n    const scaleX = effectiveWidth / preScaledWidth;\r\n    const scaleY = effectiveHeight / preScaledHeight;\r\n\r\n    this.scale = Math.min(scaleX, scaleY);\r\n\r\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\r\n    const yCenteringBuffer =\r\n      padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\r\n\r\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\r\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\r\n  }\r\n\r\n  convertExternalPoint(point: Point) {\r\n    const x = (point.x - this.xOffset) / this.scale;\r\n    const y = (this.height - this.yOffset - point.y) / this.scale;\r\n    return { x, y };\r\n  }\r\n}\r\n","import { average } from './utils';\r\nimport {\r\n  cosineSimilarity,\r\n  equals,\r\n  frechetDist,\r\n  distance,\r\n  subtract,\r\n  normalizeCurve,\r\n  rotate,\r\n  length,\r\n} from './geometry';\r\nimport { Point } from './typings/types';\r\nimport UserStroke from './models/UserStroke';\r\nimport Stroke from './models/Stroke';\r\nimport Character from './models/Character';\r\n\r\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\r\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\r\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\r\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\r\n\r\nexport interface StrokeMatchResultMeta {\r\n  isStrokeBackwards: boolean;\r\n}\r\n\r\nexport interface StrokeMatchResult {\r\n  isMatch: boolean;\r\n  meta: StrokeMatchResultMeta;\r\n}\r\n\r\nexport default function strokeMatches(\r\n  userStroke: UserStroke,\r\n  character: Character,\r\n  strokeNum: number,\r\n  options: {\r\n    leniency?: number;\r\n    isOutlineVisible?: boolean;\r\n    averageDistanceThreshold?: number;\r\n  } = {},\r\n): StrokeMatchResult {\r\n  const strokes = character.strokes;\r\n  const points = stripDuplicates(userStroke.points);\r\n\r\n  if (points.length < 2) {\r\n    return { isMatch: false, meta: { isStrokeBackwards: false } };\r\n  }\r\n\r\n  const { isMatch, meta, avgDist } = getMatchData(points, strokes[strokeNum], options);\r\n\r\n  if (!isMatch) {\r\n    return { isMatch, meta };\r\n  }\r\n\r\n  // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\r\n  const laterStrokes = strokes.slice(strokeNum + 1);\r\n  let closestMatchDist = avgDist;\r\n\r\n  for (let i = 0; i < laterStrokes.length; i++) {\r\n    const { isMatch, avgDist } = getMatchData(points, laterStrokes[i], {\r\n      ...options,\r\n      checkBackwards: false,\r\n    });\r\n    if (isMatch && avgDist < closestMatchDist) {\r\n      closestMatchDist = avgDist;\r\n    }\r\n  }\r\n  // if there's a better match, rather that returning false automatically, try reducing leniency instead\r\n  // if leniency is already really high we can allow some similar strokes to pass\r\n  if (closestMatchDist < avgDist) {\r\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\r\n    const leniencyAdjustment = (0.6 * (closestMatchDist + avgDist)) / (2 * avgDist);\r\n    const { isMatch, meta } = getMatchData(points, strokes[strokeNum], {\r\n      ...options,\r\n      leniency: (options.leniency || 1) * leniencyAdjustment,\r\n    });\r\n    return { isMatch, meta };\r\n  }\r\n\r\n  return { isMatch, meta };\r\n}\r\n\r\nconst startAndEndMatches = (points: Point[], closestStroke: Stroke, leniency: number) => {\r\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\r\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\r\n  return (\r\n    startingDist <= START_AND_END_DIST_THRESHOLD * leniency &&\r\n    endingDist <= START_AND_END_DIST_THRESHOLD * leniency\r\n  );\r\n};\r\n\r\n// returns a list of the direction of all segments in the line connecting the points\r\nconst getEdgeVectors = (points: Point[]) => {\r\n  const vectors: Point[] = [];\r\n  let lastPoint = points[0];\r\n  points.slice(1).forEach((point) => {\r\n    vectors.push(subtract(point, lastPoint));\r\n    lastPoint = point;\r\n  });\r\n  return vectors;\r\n};\r\n\r\nconst directionMatches = (points: Point[], stroke: Stroke) => {\r\n  const edgeVectors = getEdgeVectors(points);\r\n  const strokeVectors = stroke.getVectors();\r\n  const similarities = edgeVectors.map((edgeVector) => {\r\n    const strokeSimilarities = strokeVectors.map((strokeVector) =>\r\n      cosineSimilarity(strokeVector, edgeVector),\r\n    );\r\n    return Math.max(...strokeSimilarities);\r\n  });\r\n  const avgSimilarity = average(similarities);\r\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\r\n};\r\n\r\nconst lengthMatches = (points: Point[], stroke: Stroke, leniency: number) => {\r\n  return (\r\n    (leniency * (length(points) + 25)) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD\r\n  );\r\n};\r\n\r\nconst stripDuplicates = (points: Point[]) => {\r\n  if (points.length < 2) return points;\r\n  const [firstPoint, ...rest] = points;\r\n  const dedupedPoints = [firstPoint];\r\n\r\n  for (const point of rest) {\r\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\r\n      dedupedPoints.push(point);\r\n    }\r\n  }\r\n\r\n  return dedupedPoints;\r\n};\r\n\r\nconst SHAPE_FIT_ROTATIONS = [\r\n  Math.PI / 16,\r\n  Math.PI / 32,\r\n  0,\r\n  (-1 * Math.PI) / 32,\r\n  (-1 * Math.PI) / 16,\r\n];\r\n\r\nconst shapeFit = (curve1: Point[], curve2: Point[], leniency: number) => {\r\n  const normCurve1 = normalizeCurve(curve1);\r\n  const normCurve2 = normalizeCurve(curve2);\r\n  let minDist = Infinity;\r\n  SHAPE_FIT_ROTATIONS.forEach((theta) => {\r\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\r\n    if (dist < minDist) {\r\n      minDist = dist;\r\n    }\r\n  });\r\n  return minDist <= FRECHET_THRESHOLD * leniency;\r\n};\r\n\r\nconst getMatchData = (\r\n  points: Point[],\r\n  stroke: Stroke,\r\n  options: {\r\n    leniency?: number;\r\n    isOutlineVisible?: boolean;\r\n    checkBackwards?: boolean;\r\n    averageDistanceThreshold?: number;\r\n  },\r\n): StrokeMatchResult & { avgDist: number } => {\r\n  const {\r\n    leniency = 1,\r\n    isOutlineVisible = false,\r\n    checkBackwards = true,\r\n    averageDistanceThreshold = 350,\r\n  } = options;\r\n  const avgDist = stroke.getAverageDistance(points);\r\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\r\n  const withinDistThresh = avgDist <= averageDistanceThreshold * distMod * leniency;\r\n  // short circuit for faster matching\r\n  if (!withinDistThresh) {\r\n    return { isMatch: false, avgDist, meta: { isStrokeBackwards: false } };\r\n  }\r\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\r\n  const directionMatch = directionMatches(points, stroke);\r\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\r\n  const lengthMatch = lengthMatches(points, stroke, leniency);\r\n\r\n  const isMatch =\r\n    withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch;\r\n\r\n  if (checkBackwards && !isMatch) {\r\n    const backwardsMatchData = getMatchData([...points].reverse(), stroke, {\r\n      ...options,\r\n      checkBackwards: false,\r\n    });\r\n\r\n    if (backwardsMatchData.isMatch) {\r\n      return {\r\n        isMatch,\r\n        avgDist,\r\n        meta: { isStrokeBackwards: true },\r\n      };\r\n    }\r\n  }\r\n\r\n  return { isMatch, avgDist, meta: { isStrokeBackwards: false } };\r\n};\r\n","import { Point } from '../typings/types';\r\n\r\nexport default class UserStroke {\r\n  id: number;\r\n  points: Point[];\r\n  externalPoints: Point[];\r\n\r\n  constructor(id: number, startingPoint: Point, startingExternalPoint: Point) {\r\n    this.id = id;\r\n    this.points = [startingPoint];\r\n    this.externalPoints = [startingExternalPoint];\r\n  }\r\n\r\n  appendPoint(point: Point, externalPoint: Point) {\r\n    this.points.push(point);\r\n    this.externalPoints.push(externalPoint);\r\n  }\r\n}\r\n","import {\r\n  cancelAnimationFrame,\r\n  requestAnimationFrame,\r\n  inflate,\r\n  performanceNow,\r\n} from './utils';\r\nimport RenderState from './RenderState';\r\nimport { RecursivePartial } from './typings/types';\r\n\r\n/** Used by `Mutation` & `Delay` */\r\nexport interface GenericMutation<\r\n  TRenderStateClass extends GenericRenderStateClass = RenderState\r\n> {\r\n  /** Allows mutations starting with the provided string to be cancelled */\r\n  scope: string;\r\n  /** Can be useful for checking whether the mutation is running */\r\n  _runningPromise: Promise<void> | undefined;\r\n  run(renderState: TRenderStateClass): Promise<void>;\r\n  pause(): void;\r\n  resume(): void;\r\n  cancel(renderState: TRenderStateClass): void;\r\n}\r\n\r\nclass Delay implements GenericMutation {\r\n  scope: string;\r\n  _runningPromise: Promise<void> | undefined;\r\n  _duration: number;\r\n  _startTime: number | null;\r\n  _paused: boolean;\r\n  _timeout!: NodeJS.Timeout;\r\n  _resolve: (() => void) | undefined;\r\n\r\n  constructor(duration: number) {\r\n    this._duration = duration;\r\n    this._startTime = null;\r\n    this._paused = false;\r\n    this.scope = `delay.${duration}`;\r\n  }\r\n\r\n  run() {\r\n    this._startTime = performanceNow();\r\n    this._runningPromise = new Promise((resolve) => {\r\n      this._resolve = resolve;\r\n      // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\r\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\r\n    }) as Promise<void>;\r\n    return this._runningPromise;\r\n  }\r\n\r\n  pause() {\r\n    if (this._paused) return;\r\n    // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\r\n    const elapsedDelay = performance.now() - (this._startTime || 0);\r\n    this._duration = Math.max(0, this._duration - elapsedDelay);\r\n    clearTimeout(this._timeout);\r\n    this._paused = true;\r\n  }\r\n\r\n  resume() {\r\n    if (!this._paused) return;\r\n    this._startTime = performance.now();\r\n    // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\r\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\r\n    this._paused = false;\r\n  }\r\n\r\n  cancel() {\r\n    clearTimeout(this._timeout!);\r\n    if (this._resolve) {\r\n      this._resolve();\r\n    }\r\n    this._resolve = undefined;\r\n  }\r\n}\r\n\r\ntype GenericRenderStateClass<T = any> = {\r\n  state: T;\r\n  updateState(changes: RecursivePartial<T>): void;\r\n};\r\n\r\nexport default class Mutation<\r\n  TRenderStateClass extends GenericRenderStateClass,\r\n  TRenderStateObj = TRenderStateClass['state']\r\n> implements GenericMutation<TRenderStateClass> {\r\n  static Delay = Delay;\r\n\r\n  scope: string;\r\n  _runningPromise: Promise<void> | undefined;\r\n  _valuesOrCallable: any;\r\n  _duration: number;\r\n  _force: boolean | undefined;\r\n  _pausedDuration: number;\r\n  _startPauseTime: number | null;\r\n\r\n  // Only set on .run()\r\n  _startTime: number | undefined;\r\n  _startState: RecursivePartial<TRenderStateObj> | undefined;\r\n  _renderState: TRenderStateClass | undefined;\r\n  _frameHandle: number | undefined;\r\n  _values: RecursivePartial<TRenderStateObj> | undefined;\r\n  _resolve: ((_val?: any) => void) | undefined;\r\n\r\n  /**\r\n   *\r\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\r\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\r\n   */\r\n  constructor(\r\n    scope: string,\r\n    valuesOrCallable: any,\r\n    options: {\r\n      duration?: number;\r\n      /** Updates render state regardless if cancelled */\r\n      force?: boolean;\r\n    } = {},\r\n  ) {\r\n    this.scope = scope;\r\n    this._valuesOrCallable = valuesOrCallable;\r\n    this._duration = options.duration || 0;\r\n    this._force = options.force;\r\n    this._pausedDuration = 0;\r\n    this._startPauseTime = null;\r\n  }\r\n\r\n  run(renderState: TRenderStateClass): Promise<void> {\r\n    if (!this._values) this._inflateValues(renderState);\r\n    if (this._duration === 0) renderState.updateState(this._values!);\r\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\r\n      return Promise.resolve();\r\n    }\r\n    this._renderState = renderState;\r\n    this._startState = renderState.state;\r\n    this._startTime = performance.now();\r\n    this._frameHandle = requestAnimationFrame(this._tick);\r\n    return new Promise((resolve) => {\r\n      this._resolve = resolve;\r\n    });\r\n  }\r\n\r\n  private _inflateValues(renderState: TRenderStateClass) {\r\n    let values = this._valuesOrCallable;\r\n    if (typeof this._valuesOrCallable === 'function') {\r\n      values = this._valuesOrCallable(renderState.state);\r\n    }\r\n    this._values = inflate(this.scope, values);\r\n  }\r\n\r\n  pause() {\r\n    if (this._startPauseTime !== null) {\r\n      return;\r\n    }\r\n    if (this._frameHandle) {\r\n      cancelAnimationFrame(this._frameHandle);\r\n    }\r\n    this._startPauseTime = performance.now();\r\n  }\r\n\r\n  resume() {\r\n    if (this._startPauseTime === null) {\r\n      return;\r\n    }\r\n    this._frameHandle = requestAnimationFrame(this._tick);\r\n    this._pausedDuration += performance.now() - this._startPauseTime;\r\n    this._startPauseTime = null;\r\n  }\r\n\r\n  private _tick = (timing: number) => {\r\n    if (this._startPauseTime !== null) {\r\n      return;\r\n    }\r\n\r\n    const progress = Math.min(\r\n      1,\r\n      (timing - this._startTime! - this._pausedDuration) / this._duration,\r\n    );\r\n\r\n    if (progress === 1) {\r\n      this._renderState!.updateState(this._values!);\r\n      this._frameHandle = undefined;\r\n      this.cancel(this._renderState!);\r\n    } else {\r\n      const easedProgress = ease(progress);\r\n      const stateChanges = getPartialValues(\r\n        this._startState as TRenderStateObj,\r\n        this._values!,\r\n        easedProgress,\r\n      );\r\n\r\n      this._renderState!.updateState(stateChanges);\r\n      this._frameHandle = requestAnimationFrame(this._tick);\r\n    }\r\n  };\r\n\r\n  cancel(renderState: TRenderStateClass) {\r\n    this._resolve?.();\r\n    this._resolve = undefined;\r\n\r\n    cancelAnimationFrame(this._frameHandle || -1);\r\n    this._frameHandle = undefined;\r\n\r\n    if (this._force) {\r\n      if (!this._values) this._inflateValues(renderState);\r\n      renderState.updateState(this._values!);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getPartialValues<T>(\r\n  startValues: T | undefined,\r\n  endValues: RecursivePartial<T> | undefined,\r\n  progress: number,\r\n) {\r\n  const target: RecursivePartial<T> = {};\r\n\r\n  for (const key in endValues) {\r\n    const endValue = endValues[key];\r\n    const startValue = startValues?.[key];\r\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\r\n      target[key] = progress * (endValue - startValue) + startValue;\r\n    } else {\r\n      target[key] = getPartialValues(startValue, endValue, progress);\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\nfunction isAlreadyAtEnd<T>(\r\n  startValues: T | undefined,\r\n  endValues: RecursivePartial<T> | undefined,\r\n) {\r\n  for (const key in endValues) {\r\n    const endValue = endValues[key];\r\n    const startValue = startValues?.[key];\r\n    if (endValue >= 0) {\r\n      if (endValue !== startValue) {\r\n        return false;\r\n      }\r\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// from https://github.com/maxwellito/vivus\r\nconst ease = (x: number) => -Math.cos(x * Math.PI) / 2 + 0.5;\r\n","import Stroke from './models/Stroke';\r\nimport { ColorObject, RecursivePartial } from './typings/types';\r\nimport Character from './models/Character';\r\nimport Mutation, { GenericMutation } from './Mutation';\r\nimport { objRepeat } from './utils';\r\nimport { CharacterName, CharacterRenderState, RenderStateObject } from './RenderState';\r\n\r\nexport const showStrokes = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  duration: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation(\r\n      `character.${charName}.strokes`,\r\n      objRepeat(\r\n        { opacity: 1, displayPortion: 1 },\r\n        character.strokes.length,\r\n      ) as CharacterRenderState['strokes'],\r\n      { duration, force: true },\r\n    ),\r\n  ];\r\n};\r\n\r\nexport const showCharacter = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  duration: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation(\r\n      `character.${charName}`,\r\n      {\r\n        opacity: 1,\r\n        strokes: objRepeat({ opacity: 1, displayPortion: 1 }, character.strokes.length),\r\n      },\r\n      { duration, force: true },\r\n    ),\r\n  ];\r\n};\r\n\r\nexport const hideCharacter = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  duration?: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation(`character.${charName}.opacity`, 0, { duration, force: true }),\r\n    ...showStrokes(charName, character, 0),\r\n  ];\r\n};\r\n\r\nexport const updateColor = (\r\n  colorName: string,\r\n  colorVal: ColorObject | null,\r\n  duration: number,\r\n) => {\r\n  return [new Mutation(`options.${colorName}`, colorVal, { duration })];\r\n};\r\n\r\nexport const highlightStroke = (\r\n  stroke: Stroke,\r\n  color: ColorObject | null,\r\n  speed: number,\r\n): GenericMutation[] => {\r\n  const strokeNum = stroke.strokeNum;\r\n  const duration = (stroke.getLength() + 600) / (3 * speed);\r\n  return [\r\n    new Mutation('options.highlightColor', color),\r\n    new Mutation('character.highlight', {\r\n      opacity: 1,\r\n      strokes: {\r\n        [strokeNum]: {\r\n          displayPortion: 0,\r\n          opacity: 0,\r\n        },\r\n      },\r\n    }),\r\n    new Mutation(\r\n      `character.highlight.strokes.${strokeNum}`,\r\n      {\r\n        displayPortion: 1,\r\n        opacity: 1,\r\n      },\r\n      { duration },\r\n    ),\r\n    new Mutation(`character.highlight.strokes.${strokeNum}.opacity`, 0, {\r\n      duration,\r\n      force: true,\r\n    }),\r\n  ];\r\n};\r\n\r\nexport const animateStroke = (\r\n  charName: CharacterName,\r\n  stroke: Stroke,\r\n  speed: number,\r\n): GenericMutation[] => {\r\n  const strokeNum = stroke.strokeNum;\r\n  const duration = (stroke.getLength() + 600) / (3 * speed);\r\n  return [\r\n    new Mutation(`character.${charName}`, {\r\n      opacity: 1,\r\n      strokes: {\r\n        [strokeNum]: {\r\n          displayPortion: 0,\r\n          opacity: 1,\r\n        },\r\n      },\r\n    }),\r\n    new Mutation(`character.${charName}.strokes.${strokeNum}.displayPortion`, 1, {\r\n      duration,\r\n    }),\r\n  ];\r\n};\r\n\r\nexport const animateSingleStroke = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  strokeNum: number,\r\n  speed: number,\r\n): GenericMutation[] => {\r\n  const mutationStateFunc = (state: RenderStateObject) => {\r\n    const curCharState = state.character[charName];\r\n    const mutationState: RecursivePartial<CharacterRenderState> = {\r\n      opacity: 1,\r\n      strokes: {},\r\n    };\r\n    for (let i = 0; i < character.strokes.length; i++) {\r\n      mutationState.strokes![i] = {\r\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity,\r\n      };\r\n    }\r\n    return mutationState;\r\n  };\r\n  const stroke = character.strokes[strokeNum];\r\n  return [\r\n    new Mutation(`character.${charName}`, mutationStateFunc),\r\n    ...animateStroke(charName, stroke, speed),\r\n  ];\r\n};\r\n\r\nexport const showStroke = (\r\n  charName: CharacterName,\r\n  strokeNum: number,\r\n  duration: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation(\r\n      `character.${charName}.strokes.${strokeNum}`,\r\n      {\r\n        displayPortion: 1,\r\n        opacity: 1,\r\n      },\r\n      { duration, force: true },\r\n    ),\r\n  ];\r\n};\r\n\r\nexport const animateCharacter = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  fadeDuration: number,\r\n  speed: number,\r\n  delayBetweenStrokes: number,\r\n): GenericMutation[] => {\r\n  let mutations: GenericMutation[] = hideCharacter(charName, character, fadeDuration);\r\n  mutations = mutations.concat(showStrokes(charName, character, 0));\r\n  mutations.push(\r\n    new Mutation(\r\n      `character.${charName}`,\r\n      {\r\n        opacity: 1,\r\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\r\n      },\r\n      { force: true },\r\n    ),\r\n  );\r\n  character.strokes.forEach((stroke, i) => {\r\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\r\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\r\n  });\r\n  return mutations;\r\n};\r\n\r\nexport const animateCharacterLoop = (\r\n  charName: CharacterName,\r\n  character: Character,\r\n  fadeDuration: number,\r\n  speed: number,\r\n  delayBetweenStrokes: number,\r\n  delayBetweenLoops: number,\r\n): GenericMutation[] => {\r\n  const mutations = animateCharacter(\r\n    charName,\r\n    character,\r\n    fadeDuration,\r\n    speed,\r\n    delayBetweenStrokes,\r\n  );\r\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\r\n  return mutations;\r\n};\r\n","import Mutation, { GenericMutation } from './Mutation';\r\nimport * as characterActions from './characterActions';\r\nimport { objRepeat, objRepeatCb } from './utils';\r\nimport Character from './models/Character';\r\nimport { ColorObject, Point } from './typings/types';\r\n\r\nexport const startQuiz = (\r\n  character: Character,\r\n  fadeDuration: number,\r\n  startStrokeNum: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    ...characterActions.hideCharacter('main', character, fadeDuration),\r\n    new Mutation(\r\n      'character.highlight',\r\n      {\r\n        opacity: 1,\r\n        strokes: objRepeat({ opacity: 0 }, character.strokes.length),\r\n      },\r\n      { force: true },\r\n    ),\r\n    new Mutation(\r\n      'character.main',\r\n      {\r\n        opacity: 1,\r\n        strokes: objRepeatCb(character.strokes.length, (i) => ({\r\n          opacity: i < startStrokeNum ? 1 : 0,\r\n        })),\r\n      },\r\n      { force: true },\r\n    ),\r\n  ];\r\n};\r\n\r\nexport const startUserStroke = (id: string | number, point: Point): GenericMutation[] => {\r\n  return [\r\n    new Mutation('quiz.activeUserStrokeId', id, { force: true }),\r\n    new Mutation(\r\n      `userStrokes.${id}`,\r\n      {\r\n        points: [point],\r\n        opacity: 1,\r\n      },\r\n      { force: true },\r\n    ),\r\n  ];\r\n};\r\n\r\nexport const updateUserStroke = (\r\n  userStrokeId: string | number,\r\n  points: Point[],\r\n): GenericMutation[] => {\r\n  return [new Mutation(`userStrokes.${userStrokeId}.points`, points, { force: true })];\r\n};\r\n\r\nexport const hideUserStroke = (\r\n  userStrokeId: string | number,\r\n  duration: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation(`userStrokes.${userStrokeId}.opacity`, 0, { duration }),\r\n    // Do not remove the stroke, keep it hidden until quiz ends\r\n    // This avoids a bug in which touchmove stops being triggered in the middle of a stroke\r\n    // the only doc i found https://stackoverflow.com/questions/29384973/touchmove-event-stops-triggering-after-any-element-is-removed-from-dom\r\n    // so if the user on his phone is too quick to start his new stroke, the new stroke may stops in mid air\r\n    //new Mutation(`userStrokes.${userStrokeId}`, null, { force: true }),\r\n  ];\r\n};\r\n\r\nexport const removeAllUserStrokes = (userStrokeIds: Array<number>): GenericMutation[] => {\r\n  return userStrokeIds?.map(userStrokeId =>\r\n    new Mutation(`userStrokes.${userStrokeId}`, null, { force: true })\r\n  ) || [];\r\n};\r\n\r\nexport const highlightCompleteChar = (\r\n  character: Character,\r\n  color: ColorObject | null,\r\n  duration: number,\r\n): GenericMutation[] => {\r\n  return [\r\n    new Mutation('options.highlightColor', color),\r\n    ...characterActions.hideCharacter('highlight', character),\r\n    ...characterActions.showCharacter('highlight', character, duration / 2),\r\n    ...characterActions.hideCharacter('highlight', character, duration / 2),\r\n  ];\r\n};\r\n\r\nexport const highlightStroke = characterActions.highlightStroke;\r\n","import strokeMatches, { StrokeMatchResultMeta } from './strokeMatches';\r\nimport UserStroke from './models/UserStroke';\r\nimport Positioner from './Positioner';\r\nimport { counter, colorStringToVals, fixIndex } from './utils';\r\nimport * as quizActions from './quizActions';\r\nimport * as geometry from './geometry';\r\nimport * as characterActions from './characterActions';\r\nimport Character from './models/Character';\r\nimport { ParsedHanziWriterOptions, Point, StrokeData } from './typings/types';\r\nimport RenderState from './RenderState';\r\nimport { GenericMutation } from './Mutation';\r\n\r\nconst getDrawnPath = (userStroke: UserStroke) => ({\r\n  pathString: geometry.getPathString(userStroke.externalPoints),\r\n  points: userStroke.points.map((point) => geometry.round(point)),\r\n});\r\n\r\nexport default class Quiz {\r\n  _character: Character;\r\n  _renderState: RenderState;\r\n  _isActive: boolean;\r\n  _positioner: Positioner;\r\n\r\n  /** Set on startQuiz */\r\n  _options: ParsedHanziWriterOptions | undefined;\r\n  _currentStrokeIndex = 0;\r\n  _mistakesOnStroke = 0;\r\n  _totalMistakes = 0;\r\n  _userStroke: UserStroke | undefined;\r\n  _userStrokesIds: Array<number> | undefined;\r\n\r\n  constructor(character: Character, renderState: RenderState, positioner: Positioner) {\r\n    this._character = character;\r\n    this._renderState = renderState;\r\n    this._isActive = false;\r\n    this._positioner = positioner;\r\n  }\r\n\r\n  startQuiz(options: ParsedHanziWriterOptions) {\r\n    if (this._userStrokesIds) {\r\n      this._renderState.run(\r\n        quizActions.removeAllUserStrokes( this._userStrokesIds ),\r\n      );\r\n    }\r\n    this._userStrokesIds = []\r\n\r\n    this._isActive = true;\r\n    this._options = options;\r\n    const startIndex = fixIndex(\r\n      options.quizStartStrokeNum,\r\n      this._character.strokes.length,\r\n    );\r\n    this._currentStrokeIndex = Math.min(startIndex, this._character.strokes.length - 1);\r\n    this._mistakesOnStroke = 0;\r\n    this._totalMistakes = 0;\r\n\r\n    return this._renderState.run(\r\n      quizActions.startQuiz(\r\n        this._character,\r\n        options.strokeFadeDuration,\r\n        this._currentStrokeIndex,\r\n      ),\r\n    );\r\n  }\r\n\r\n  startUserStroke(externalPoint: Point) {\r\n    if (!this._isActive) {\r\n      return null;\r\n    }\r\n    if (this._userStroke) {\r\n      return this.endUserStroke();\r\n    }\r\n    const point = this._positioner.convertExternalPoint(externalPoint);\r\n    const strokeId = counter();\r\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\r\n    this._userStrokesIds?.push(strokeId)\r\n    return this._renderState.run(quizActions.startUserStroke(strokeId, point));\r\n  }\r\n\r\n  continueUserStroke(externalPoint: Point) {\r\n    if (!this._userStroke) {\r\n      return Promise.resolve();\r\n    }\r\n    const point = this._positioner.convertExternalPoint(externalPoint);\r\n    this._userStroke.appendPoint(point, externalPoint);\r\n    const nextPoints = this._userStroke.points.slice(0);\r\n    return this._renderState.run(\r\n      quizActions.updateUserStroke(this._userStroke.id, nextPoints),\r\n    );\r\n  }\r\n\r\n  setPositioner(positioner: Positioner) {\r\n    this._positioner = positioner;\r\n  }\r\n\r\n  endUserStroke() {\r\n    if (!this._userStroke) return;\r\n\r\n    this._renderState.run(\r\n      quizActions.hideUserStroke(\r\n        this._userStroke.id,\r\n        this._options!.drawingFadeDuration ?? 300,\r\n      ),\r\n    );\r\n\r\n    // skip single-point strokes\r\n    if (this._userStroke.points.length === 1) {\r\n      this._userStroke = undefined;\r\n      return;\r\n    }\r\n\r\n    const { acceptBackwardsStrokes, markStrokeCorrectAfterMisses } = this._options!;\r\n\r\n    const currentStroke = this._getCurrentStroke();\r\n    const { isMatch, meta } = strokeMatches(\r\n      this._userStroke,\r\n      this._character,\r\n      this._currentStrokeIndex,\r\n      {\r\n        isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\r\n        leniency: this._options!.leniency,\r\n        averageDistanceThreshold: this._options!.averageDistanceThreshold,\r\n      },\r\n    );\r\n\r\n    // if markStrokeCorrectAfterMisses is passed, just force the stroke to count as correct after n tries\r\n    const isForceAccepted =\r\n      markStrokeCorrectAfterMisses &&\r\n      this._mistakesOnStroke + 1 >= markStrokeCorrectAfterMisses;\r\n\r\n    const isAccepted =\r\n      isMatch || isForceAccepted || (meta.isStrokeBackwards && acceptBackwardsStrokes);\r\n\r\n    if (isAccepted) {\r\n      this._handleSuccess(meta);\r\n    } else {\r\n      this._handleFailure(meta);\r\n\r\n      const {\r\n        showHintAfterMisses,\r\n        highlightColor,\r\n        strokeHighlightSpeed,\r\n      } = this._options!;\r\n\r\n      if (\r\n        showHintAfterMisses !== false &&\r\n        this._mistakesOnStroke >= showHintAfterMisses\r\n      ) {\r\n        this._renderState.run(\r\n          characterActions.highlightStroke(\r\n            currentStroke,\r\n            colorStringToVals(highlightColor),\r\n            strokeHighlightSpeed,\r\n          ),\r\n        );\r\n      }\r\n    }\r\n\r\n    this._userStroke = undefined;\r\n  }\r\n\r\n  cancel() {\r\n    this._isActive = false;\r\n    if (this._userStrokesIds) {\r\n      this._renderState.run(\r\n        quizActions.removeAllUserStrokes( this._userStrokesIds ),\r\n      );\r\n    }\r\n  }\r\n\r\n  _getStrokeData({\r\n    isCorrect,\r\n    meta,\r\n  }: {\r\n    isCorrect: boolean;\r\n    meta: StrokeMatchResultMeta;\r\n  }): StrokeData {\r\n    return {\r\n      character: this._character.symbol,\r\n      strokeNum: this._currentStrokeIndex,\r\n      mistakesOnStroke: this._mistakesOnStroke,\r\n      totalMistakes: this._totalMistakes,\r\n      strokesRemaining:\r\n        this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\r\n      drawnPath: getDrawnPath(this._userStroke!),\r\n      isBackwards: meta.isStrokeBackwards,\r\n    };\r\n  }\r\n\r\n  nextStroke() {\r\n    if (!this._options) return;\r\n\r\n    const { strokes, symbol } = this._character;\r\n\r\n    const {\r\n      onComplete,\r\n      highlightOnComplete,\r\n      strokeFadeDuration,\r\n      highlightCompleteColor,\r\n      highlightColor,\r\n      strokeHighlightDuration,\r\n    } = this._options;\r\n\r\n    let animation: GenericMutation[] = characterActions.showStroke(\r\n      'main',\r\n      this._currentStrokeIndex,\r\n      strokeFadeDuration,\r\n    );\r\n\r\n    this._mistakesOnStroke = 0;\r\n    this._currentStrokeIndex += 1;\r\n\r\n    const isComplete = this._currentStrokeIndex === strokes.length;\r\n\r\n    if (isComplete) {\r\n      this._isActive = false;\r\n      onComplete?.({\r\n        character: symbol,\r\n        totalMistakes: this._totalMistakes,\r\n      });\r\n      if (highlightOnComplete) {\r\n        animation = animation.concat(\r\n          quizActions.highlightCompleteChar(\r\n            this._character,\r\n            colorStringToVals(highlightCompleteColor || highlightColor),\r\n            (strokeHighlightDuration || 0) * 2,\r\n          ),\r\n        );\r\n      }\r\n    }\r\n\r\n    this._renderState.run(animation);\r\n  }\r\n\r\n  _handleSuccess(meta: StrokeMatchResultMeta) {\r\n    if (!this._options) return;\r\n\r\n    const { onCorrectStroke } = this._options;\r\n\r\n    onCorrectStroke?.({\r\n      ...this._getStrokeData({ isCorrect: true, meta }),\r\n    });\r\n\r\n    this.nextStroke();\r\n  }\r\n\r\n  _handleFailure(meta: StrokeMatchResultMeta) {\r\n    this._mistakesOnStroke += 1;\r\n    this._totalMistakes += 1;\r\n    this._options!.onMistake?.(this._getStrokeData({ isCorrect: false, meta }));\r\n  }\r\n\r\n  _getCurrentStroke() {\r\n    return this._character.strokes[this._currentStrokeIndex];\r\n  }\r\n}\r\n","export function createElm(elmType: string) {\r\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\r\n}\r\n\r\nexport function attr(elm: Element, name: string, value: string) {\r\n  elm.setAttributeNS(null, name, value);\r\n}\r\n\r\nexport function attrs(elm: Element, attrsMap: Record<string, string>) {\r\n  Object.keys(attrsMap).forEach((attrName) => attr(elm, attrName, attrsMap[attrName]));\r\n}\r\n\r\n// inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\r\nexport function urlIdRef(id: string) {\r\n  let prefix = '';\r\n  if (window.location && window.location.href) {\r\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\r\n  }\r\n  return `url(\"${prefix}#${id}\")`;\r\n}\r\n\r\nexport function removeElm(elm: Element | undefined) {\r\n  elm?.parentNode?.removeChild(elm);\r\n}\r\n","import Stroke from '../models/Stroke';\r\nimport { ColorObject } from '../typings/types';\r\n\r\nexport default class StrokeRendererBase {\r\n  _pathLength: number;\r\n  stroke: Stroke;\r\n  static STROKE_WIDTH = 200;\r\n\r\n  constructor(stroke: Stroke) {\r\n    this.stroke = stroke;\r\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\r\n  }\r\n\r\n  _getStrokeDashoffset(displayPortion: number) {\r\n    return this._pathLength * 0.999 * (1 - displayPortion);\r\n  }\r\n\r\n  _getColor({\r\n    strokeColor,\r\n    radicalColor,\r\n  }: {\r\n    strokeColor: ColorObject;\r\n    radicalColor?: ColorObject | null;\r\n  }) {\r\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\r\n  }\r\n}\r\n","import { counter } from '../../utils';\r\nimport * as svg from './svgUtils';\r\nimport { extendStart, getPathString } from '../../geometry';\r\nimport StrokeRendererBase from '../StrokeRendererBase';\r\nimport Stroke from '../../models/Stroke';\r\nimport SVGRenderTarget from './RenderTarget';\r\nimport { ColorObject } from '../../typings/types';\r\n\r\nconst STROKE_WIDTH = 200;\r\n\r\ntype StrokeRenderProps = {\r\n  strokeColor: ColorObject;\r\n  radicalColor: ColorObject | null;\r\n  displayPortion: number;\r\n  opacity: number;\r\n};\r\n\r\n/** This is a stroke composed of several stroke parts **/\r\nexport default class StrokeRenderer extends StrokeRendererBase {\r\n  _oldProps: StrokeRenderProps | undefined = undefined;\r\n\r\n  _animationPath: SVGPathElement | undefined;\r\n  _clip: SVGClipPathElement | undefined;\r\n  _strokePath: SVGPathElement | undefined;\r\n\r\n  constructor(stroke: Stroke) {\r\n    super(stroke);\r\n  }\r\n\r\n  mount(target: SVGRenderTarget) {\r\n    this._animationPath = svg.createElm('path') as SVGPathElement;\r\n    this._clip = svg.createElm('clipPath') as SVGClipPathElement;\r\n    this._strokePath = svg.createElm('path') as SVGPathElement;\r\n    const maskId = `mask-${counter()}`;\r\n    svg.attr(this._clip, 'id', maskId);\r\n\r\n    svg.attr(this._strokePath, 'd', this.stroke.path);\r\n    this._animationPath.style.opacity = '0';\r\n    svg.attr(this._animationPath, 'clip-path', svg.urlIdRef(maskId));\r\n\r\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\r\n    svg.attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\r\n    svg.attrs(this._animationPath, {\r\n      stroke: '#FFFFFF',\r\n      'stroke-width': STROKE_WIDTH.toString(),\r\n      fill: 'none',\r\n      'stroke-linecap': 'round',\r\n      'stroke-linejoin': 'miter',\r\n      'stroke-dasharray': `${this._pathLength},${this._pathLength}`,\r\n    });\r\n\r\n    this._clip.appendChild(this._strokePath);\r\n    target.defs.appendChild(this._clip);\r\n    target.svg.appendChild(this._animationPath);\r\n    return this;\r\n  }\r\n\r\n  render(props: StrokeRenderProps) {\r\n    if (props === this._oldProps || !this._animationPath) {\r\n      return;\r\n    }\r\n\r\n    if (props.displayPortion !== this._oldProps?.displayPortion) {\r\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(\r\n        props.displayPortion,\r\n      ).toString();\r\n    }\r\n\r\n    const color = this._getColor(props);\r\n\r\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\r\n      const { r, g, b, a } = color;\r\n      svg.attrs(this._animationPath, { stroke: `rgba(${r},${g},${b},${a})` });\r\n    }\r\n\r\n    if (props.opacity !== this._oldProps?.opacity) {\r\n      this._animationPath.style.opacity = props.opacity.toString();\r\n    }\r\n    this._oldProps = props;\r\n  }\r\n}\r\n","import { isMsBrowser } from '../../utils';\r\nimport StrokeRenderer from './StrokeRenderer';\r\nimport SVGRenderTarget from './RenderTarget';\r\nimport Character from '../../models/Character';\r\nimport { ColorObject } from '../../typings/types';\r\nimport { StrokeRenderState } from '../../RenderState';\r\n\r\ntype SvgCharacterRenderProps = {\r\n  opacity: number;\r\n  strokes: Record<number, StrokeRenderState>;\r\n  strokeColor: ColorObject;\r\n  radicalColor?: ColorObject | null;\r\n};\r\n\r\nexport default class CharacterRenderer {\r\n  _oldProps: SvgCharacterRenderProps | undefined = undefined;\r\n  _strokeRenderers: StrokeRenderer[];\r\n\r\n  // set on mount()\r\n  _group: SVGElement | SVGSVGElement | undefined;\r\n\r\n  constructor(character: Character) {\r\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\r\n  }\r\n\r\n  mount(target: SVGRenderTarget) {\r\n    const subTarget = target.createSubRenderTarget();\r\n    this._group = subTarget.svg;\r\n    this._strokeRenderers.forEach((strokeRenderer) => {\r\n      strokeRenderer.mount(subTarget);\r\n    });\r\n  }\r\n\r\n  render(props: SvgCharacterRenderProps) {\r\n    if (props === this._oldProps || !this._group) {\r\n      return;\r\n    }\r\n    const { opacity, strokes, strokeColor, radicalColor = null } = props;\r\n    if (opacity !== this._oldProps?.opacity) {\r\n      this._group.style.opacity = opacity.toString();\r\n      // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\r\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\r\n      // this is just a perf improvement, so disable for MS browsers\r\n      if (!isMsBrowser) {\r\n        if (opacity === 0) {\r\n          this._group.style.display = 'none';\r\n        } else if (this._oldProps?.opacity === 0) {\r\n          this._group.style.removeProperty('display');\r\n        }\r\n      }\r\n    }\r\n    const colorsChanged =\r\n      !this._oldProps ||\r\n      strokeColor !== this._oldProps.strokeColor ||\r\n      radicalColor !== this._oldProps.radicalColor;\r\n\r\n    if (colorsChanged || strokes !== this._oldProps?.strokes) {\r\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\r\n        if (\r\n          !colorsChanged &&\r\n          this._oldProps?.strokes &&\r\n          strokes[i] === this._oldProps.strokes[i]\r\n        ) {\r\n          continue;\r\n        }\r\n        this._strokeRenderers[i].render({\r\n          strokeColor,\r\n          radicalColor,\r\n          opacity: strokes[i].opacity,\r\n          displayPortion: strokes[i].displayPortion,\r\n        });\r\n      }\r\n    }\r\n    this._oldProps = props;\r\n  }\r\n}\r\n","import * as svg from './svgUtils';\r\nimport { getPathString } from '../../geometry';\r\nimport { ColorObject, Point } from '../../typings/types';\r\nimport SVGRenderTarget from './RenderTarget';\r\n\r\nexport type UserStrokeProps = {\r\n  strokeWidth: number;\r\n  strokeColor: ColorObject;\r\n  opacity: number;\r\n  points: Point[];\r\n};\r\n\r\nexport default class UserStrokeRenderer {\r\n  _oldProps: UserStrokeProps | undefined = undefined;\r\n  _path: SVGElement | undefined;\r\n\r\n  mount(target: SVGRenderTarget) {\r\n    this._path = svg.createElm('path');\r\n    target.svg.appendChild(this._path);\r\n  }\r\n\r\n  render(props: UserStrokeProps) {\r\n    if (!this._path || props === this._oldProps) {\r\n      return;\r\n    }\r\n    if (\r\n      props.strokeColor !== this._oldProps?.strokeColor ||\r\n      props.strokeWidth !== this._oldProps?.strokeWidth\r\n    ) {\r\n      const { r, g, b, a } = props.strokeColor;\r\n      svg.attrs(this._path, {\r\n        fill: 'none',\r\n        stroke: `rgba(${r},${g},${b},${a})`,\r\n        'stroke-width': props.strokeWidth.toString(),\r\n        'stroke-linecap': 'round',\r\n        'stroke-linejoin': 'round',\r\n      });\r\n    }\r\n    if (props.opacity !== this._oldProps?.opacity) {\r\n      svg.attr(this._path, 'opacity', props.opacity.toString());\r\n    }\r\n    if (props.points !== this._oldProps?.points) {\r\n      svg.attr(this._path, 'd', getPathString(props.points));\r\n    }\r\n    this._oldProps = props;\r\n  }\r\n\r\n  destroy() {\r\n    svg.removeElm(this._path);\r\n  }\r\n}\r\n","import { Point } from '../typings/types';\r\n\r\ntype BoundEvent = {\r\n  getPoint(): Point;\r\n  preventDefault(): void;\r\n};\r\n\r\n/** Generic render target */\r\nexport default class RenderTargetBase<\r\n  TElement extends\r\n    | HTMLElement\r\n    | SVGElement\r\n    | SVGSVGElement\r\n    | HTMLCanvasElement = HTMLElement\r\n> {\r\n  node: TElement;\r\n\r\n  constructor(node: TElement) {\r\n    this.node = node;\r\n  }\r\n\r\n  addPointerStartListener(callback: (arg: BoundEvent) => void) {\r\n    this.node.addEventListener('mousedown', (evt) => {\r\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\r\n    });\r\n    this.node.addEventListener('touchstart', (evt) => {\r\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\r\n    });\r\n  }\r\n\r\n  addPointerMoveListener(callback: (arg: BoundEvent) => void) {\r\n    this.node.addEventListener('mousemove', (evt) => {\r\n      callback(this._eventify(evt as MouseEvent, this._getMousePoint));\r\n    });\r\n    this.node.addEventListener('touchmove', (evt) => {\r\n      callback(this._eventify(evt as TouchEvent, this._getTouchPoint));\r\n    });\r\n  }\r\n\r\n  addPointerEndListener(callback: () => void) {\r\n    // TODO: find a way to not need global listeners\r\n    document.addEventListener('mouseup', callback);\r\n    document.addEventListener('touchend', callback);\r\n  }\r\n\r\n  getBoundingClientRect() {\r\n    return this.node.getBoundingClientRect();\r\n  }\r\n\r\n  updateDimensions(width: string | number, height: string | number) {\r\n    this.node.setAttribute('width', `${width}`);\r\n    this.node.setAttribute('height', `${height}`);\r\n  }\r\n\r\n  _eventify<TEvent extends Event>(evt: TEvent, pointFunc: (event: TEvent) => Point) {\r\n    return {\r\n      getPoint: () => pointFunc.call(this, evt),\r\n      preventDefault: () => evt.preventDefault(),\r\n    };\r\n  }\r\n\r\n  _getMousePoint(evt: MouseEvent): Point {\r\n    const { left, top } = this.getBoundingClientRect();\r\n    const x = evt.clientX - left;\r\n    const y = evt.clientY - top;\r\n    return { x, y };\r\n  }\r\n\r\n  _getTouchPoint(evt: TouchEvent): Point {\r\n    const { left, top } = this.getBoundingClientRect();\r\n    const x = evt.touches[0].clientX - left;\r\n    const y = evt.touches[0].clientY - top;\r\n    return { x, y };\r\n  }\r\n}\r\n","import { createElm, attrs } from './svgUtils';\r\nimport RenderTargetBase from '../RenderTargetBase';\r\n\r\nexport default class RenderTarget extends RenderTargetBase<SVGSVGElement | SVGElement> {\r\n  static init(elmOrId: Element | string, width = '100%', height = '100%') {\r\n    const element = (() => {\r\n      if (typeof elmOrId === 'string') {\r\n        return document.getElementById(elmOrId);\r\n      }\r\n      return elmOrId;\r\n    })();\r\n\r\n    if (!element) {\r\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\r\n    }\r\n    const nodeType = element.nodeName.toUpperCase();\r\n\r\n    const svg = (() => {\r\n      if (nodeType === 'SVG' || nodeType === 'G') {\r\n        return element;\r\n      } else {\r\n        const svg = createElm('svg');\r\n        element.appendChild(svg);\r\n        return svg;\r\n      }\r\n    })() as SVGSVGElement;\r\n\r\n    attrs(svg, { width, height });\r\n    const defs = createElm('defs');\r\n    svg.appendChild(defs);\r\n\r\n    return new RenderTarget(svg, defs);\r\n  }\r\n\r\n  svg: SVGSVGElement | SVGElement;\r\n  defs: SVGElement;\r\n  _pt: DOMPoint | undefined;\r\n\r\n  constructor(svg: SVGElement | SVGSVGElement, defs: SVGElement) {\r\n    super(svg);\r\n\r\n    this.svg = svg;\r\n    this.defs = defs;\r\n\r\n    if ('createSVGPoint' in svg) {\r\n      this._pt = svg.createSVGPoint();\r\n    }\r\n  }\r\n\r\n  createSubRenderTarget() {\r\n    const group = createElm('g');\r\n    this.svg.appendChild(group);\r\n    return new RenderTarget(group, this.defs);\r\n  }\r\n\r\n  _getMousePoint(evt: MouseEvent) {\r\n    if (this._pt) {\r\n      this._pt.x = evt.clientX;\r\n      this._pt.y = evt.clientY;\r\n      if ('getScreenCTM' in this.node) {\r\n        const localPt = this._pt.matrixTransform(this.node.getScreenCTM()?.inverse());\r\n        return { x: localPt.x, y: localPt.y };\r\n      }\r\n    }\r\n    return super._getMousePoint.call(this, evt);\r\n  }\r\n\r\n  _getTouchPoint(evt: TouchEvent) {\r\n    if (this._pt) {\r\n      this._pt.x = evt.touches[0].clientX;\r\n      this._pt.y = evt.touches[0].clientY;\r\n      if ('getScreenCTM' in this.node) {\r\n        const localPt = this._pt.matrixTransform(\r\n          (this.node as SVGSVGElement).getScreenCTM()?.inverse(),\r\n        );\r\n        return { x: localPt.x, y: localPt.y };\r\n      }\r\n    }\r\n    return super._getTouchPoint(evt);\r\n  }\r\n}\r\n","import { RenderTargetInitFunction } from '../../typings/types';\r\nimport HanziWriterRenderer from './HanziWriterRenderer';\r\nimport RenderTarget from './RenderTarget';\r\n\r\nexport default {\r\n  HanziWriterRenderer,\r\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<\r\n    SVGSVGElement | SVGElement\r\n  >,\r\n};\r\n","import CharacterRenderer from './CharacterRenderer';\r\nimport UserStrokeRenderer, { UserStrokeProps } from './UserStrokeRenderer';\r\nimport * as svg from './svgUtils';\r\nimport Character from '../../models/Character';\r\nimport Positioner from '../../Positioner';\r\nimport SVGRenderTarget from './RenderTarget';\r\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\r\nimport { RenderStateObject } from '../../RenderState';\r\n\r\nexport default class HanziWriterRenderer\r\n  implements HanziWriterRendererBase<SVGElement | SVGSVGElement, SVGRenderTarget> {\r\n  _character: Character;\r\n  _positioner: Positioner;\r\n  _mainCharRenderer: CharacterRenderer;\r\n  _outlineCharRenderer: CharacterRenderer;\r\n  _highlightCharRenderer: CharacterRenderer;\r\n  _userStrokeRenderers: Record<string, UserStrokeRenderer | undefined>;\r\n  _positionedTarget: SVGRenderTarget | undefined;\r\n\r\n  constructor(character: Character, positioner: Positioner) {\r\n    this._character = character;\r\n    this._positioner = positioner;\r\n    this._mainCharRenderer = new CharacterRenderer(character);\r\n    this._outlineCharRenderer = new CharacterRenderer(character);\r\n    this._highlightCharRenderer = new CharacterRenderer(character);\r\n    this._userStrokeRenderers = {};\r\n  }\r\n\r\n  mount(target: SVGRenderTarget) {\r\n    const positionedTarget = target.createSubRenderTarget();\r\n    const group = positionedTarget.svg;\r\n    const { xOffset, yOffset, height, scale } = this._positioner;\r\n\r\n    svg.attr(\r\n      group,\r\n      'transform',\r\n      `translate(${xOffset}, ${height - yOffset}) scale(${scale}, ${-1 * scale})`,\r\n    );\r\n    this._outlineCharRenderer.mount(positionedTarget);\r\n    this._mainCharRenderer.mount(positionedTarget);\r\n    this._highlightCharRenderer.mount(positionedTarget);\r\n    this._positionedTarget = positionedTarget;\r\n  }\r\n\r\n  render(props: RenderStateObject) {\r\n    const { main, outline, highlight } = props.character;\r\n    const {\r\n      outlineColor,\r\n      radicalColor,\r\n      highlightColor,\r\n      strokeColor,\r\n      drawingWidth,\r\n      drawingColor,\r\n    } = props.options;\r\n\r\n    this._outlineCharRenderer.render({\r\n      opacity: outline.opacity,\r\n      strokes: outline.strokes,\r\n      strokeColor: outlineColor,\r\n    });\r\n\r\n    this._mainCharRenderer.render({\r\n      opacity: main.opacity,\r\n      strokes: main.strokes,\r\n      strokeColor,\r\n      radicalColor: radicalColor,\r\n    });\r\n\r\n    this._highlightCharRenderer.render({\r\n      opacity: highlight.opacity,\r\n      strokes: highlight.strokes,\r\n      strokeColor: highlightColor,\r\n    });\r\n\r\n    const userStrokes = props.userStrokes || {};\r\n\r\n    for (const userStrokeId in this._userStrokeRenderers) {\r\n      if (!userStrokes[userStrokeId]) {\r\n        this._userStrokeRenderers[userStrokeId]?.destroy();\r\n        delete this._userStrokeRenderers[userStrokeId];\r\n      }\r\n    }\r\n\r\n    for (const userStrokeId in userStrokes) {\r\n      const stroke = userStrokes[userStrokeId];\r\n      if (!stroke) {\r\n        continue;\r\n      }\r\n      const userStrokeProps: UserStrokeProps = {\r\n        strokeWidth: drawingWidth,\r\n        strokeColor: drawingColor,\r\n        ...stroke,\r\n      };\r\n\r\n      const strokeRenderer = (() => {\r\n        if (this._userStrokeRenderers[userStrokeId]) {\r\n          return this._userStrokeRenderers[userStrokeId]!;\r\n        }\r\n        const newStrokeRenderer = new UserStrokeRenderer();\r\n        newStrokeRenderer.mount(this._positionedTarget!);\r\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\r\n        return newStrokeRenderer;\r\n      })();\r\n\r\n      strokeRenderer.render(userStrokeProps);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    svg.removeElm(this._positionedTarget!.svg);\r\n    this._positionedTarget!.defs.innerHTML = '';\r\n  }\r\n}\r\n","import { Point } from '../../typings/types';\r\n\r\nexport const drawPath = (ctx: CanvasRenderingContext2D, points: Point[]) => {\r\n  ctx.beginPath();\r\n  const start = points[0];\r\n  const remainingPoints = points.slice(1);\r\n  ctx.moveTo(start.x, start.y);\r\n  for (const point of remainingPoints) {\r\n    ctx.lineTo(point.x, point.y);\r\n  }\r\n  ctx.stroke();\r\n};\r\n\r\n/**\r\n * Break a path string into a series of canvas path commands\r\n *\r\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\r\n * @param pathString\r\n */\r\nexport const pathStringToCanvas = (pathString: string) => {\r\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter((part) => part !== ' ');\r\n  const commands = [(ctx: CanvasRenderingContext2D) => ctx.beginPath()];\r\n  for (const part of pathParts) {\r\n    const [cmd, ...rawParams] = part.split(/\\s+/);\r\n    const params = rawParams.map((param) => parseFloat(param)) as any[];\r\n    if (cmd === 'M') {\r\n      commands.push((ctx) => ctx.moveTo(...(params as [number, number])));\r\n    } else if (cmd === 'L') {\r\n      commands.push((ctx) => ctx.lineTo(...(params as [number, number])));\r\n    } else if (cmd === 'C') {\r\n      commands.push((ctx) =>\r\n        ctx.bezierCurveTo(...(params as Parameters<typeof ctx.bezierCurveTo>)),\r\n      );\r\n    } else if (cmd === 'Q') {\r\n      commands.push((ctx) =>\r\n        ctx.quadraticCurveTo(...(params as Parameters<typeof ctx.quadraticCurveTo>)),\r\n      );\r\n    } else if (cmd === 'Z') {\r\n      // commands.push((ctx) => ctx.closePath());\r\n    }\r\n  }\r\n  return (ctx: CanvasRenderingContext2D) => commands.forEach((cmd) => cmd(ctx));\r\n};\r\n","import { extendStart } from '../../geometry';\r\nimport { drawPath, pathStringToCanvas } from './canvasUtils';\r\nimport StrokeRendererBase from '../StrokeRendererBase';\r\nimport Stroke from '../../models/Stroke';\r\nimport { ColorObject, Point } from '../../typings/types';\r\n\r\n/** this is a stroke composed of several stroke parts */\r\nexport default class StrokeRenderer extends StrokeRendererBase {\r\n  _extendedMaskPoints: Point[];\r\n\r\n  // Conditionally set on constructor\r\n  _path2D: Path2D | undefined;\r\n  _pathCmd: ((ctx: CanvasRenderingContext2D) => void) | undefined;\r\n\r\n  constructor(stroke: Stroke, usePath2D = true) {\r\n    super(stroke);\r\n\r\n    if (usePath2D && Path2D) {\r\n      this._path2D = new Path2D(this.stroke.path);\r\n    } else {\r\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\r\n    }\r\n    this._extendedMaskPoints = extendStart(\r\n      this.stroke.points,\r\n      StrokeRendererBase.STROKE_WIDTH / 2,\r\n    );\r\n  }\r\n\r\n  render(\r\n    ctx: CanvasRenderingContext2D,\r\n    props: {\r\n      opacity: number;\r\n      strokeColor: ColorObject;\r\n      radicalColor?: ColorObject | null;\r\n      displayPortion: number;\r\n    },\r\n  ) {\r\n    if (props.opacity < 0.05) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n\r\n    if (this._path2D) {\r\n      ctx.clip(this._path2D);\r\n    } else {\r\n      this._pathCmd?.(ctx);\r\n      // wechat bugs out if the clip path isn't stroked or filled\r\n      ctx.globalAlpha = 0;\r\n      ctx.stroke();\r\n      ctx.clip();\r\n    }\r\n\r\n    const { r, g, b, a } = this._getColor(props);\r\n    const color = a === 1 ? `rgb(${r},${g},${b})` : `rgb(${r},${g},${b},${a})`;\r\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\r\n    ctx.globalAlpha = props.opacity;\r\n    ctx.strokeStyle = color;\r\n    ctx.fillStyle = color;\r\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\r\n    ctx.lineCap = 'round';\r\n    ctx.lineJoin = 'round';\r\n    // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\r\n    // @ts-ignore\r\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\r\n    ctx.lineDashOffset = dashOffset;\r\n    drawPath(ctx, this._extendedMaskPoints);\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import Character from '../../models/Character';\r\nimport { StrokeRenderState } from '../../RenderState';\r\nimport { ColorObject } from '../../typings/types';\r\nimport StrokeRenderer from './StrokeRenderer';\r\n\r\nexport default class CharacterRenderer {\r\n  _strokeRenderers: StrokeRenderer[];\r\n\r\n  constructor(character: Character) {\r\n    this._strokeRenderers = character.strokes.map((stroke) => new StrokeRenderer(stroke));\r\n  }\r\n\r\n  render(\r\n    ctx: CanvasRenderingContext2D,\r\n    props: {\r\n      opacity: number;\r\n      strokes: Record<number, StrokeRenderState>;\r\n      strokeColor: ColorObject;\r\n      radicalColor?: ColorObject | null;\r\n    },\r\n  ) {\r\n    if (props.opacity < 0.05) return;\r\n\r\n    const { opacity, strokeColor, radicalColor, strokes } = props;\r\n\r\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\r\n      this._strokeRenderers[i].render(ctx, {\r\n        strokeColor,\r\n        radicalColor,\r\n        opacity: strokes[i].opacity * opacity,\r\n        displayPortion: strokes[i].displayPortion || 0,\r\n      });\r\n    }\r\n  }\r\n}\r\n","import { ColorObject, Point } from '../../typings/types';\r\nimport { drawPath } from './canvasUtils';\r\n\r\nexport default function renderUserStroke(\r\n  ctx: CanvasRenderingContext2D,\r\n  props: {\r\n    opacity: number;\r\n    strokeWidth: number;\r\n    strokeColor: ColorObject;\r\n    points: Point[];\r\n  },\r\n) {\r\n  if (props.opacity < 0.05) {\r\n    return;\r\n  }\r\n  const { opacity, strokeWidth, strokeColor, points } = props;\r\n  const { r, g, b, a } = strokeColor;\r\n\r\n  ctx.save();\r\n  ctx.globalAlpha = opacity;\r\n  ctx.lineWidth = strokeWidth;\r\n  ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;\r\n  ctx.lineCap = 'round';\r\n  ctx.lineJoin = 'round';\r\n  drawPath(ctx, points);\r\n  ctx.restore();\r\n}\r\n","import RenderTargetBase from '../RenderTargetBase';\r\n\r\nexport default class RenderTarget extends RenderTargetBase<HTMLCanvasElement> {\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    super(canvas);\r\n  }\r\n\r\n  static init(elmOrId: string | HTMLCanvasElement, width = '100%', height = '100%') {\r\n    const element = (() => {\r\n      if (typeof elmOrId === 'string') {\r\n        return document.getElementById(elmOrId);\r\n      }\r\n      return elmOrId;\r\n    })();\r\n\r\n    if (!element) {\r\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\r\n    }\r\n\r\n    const nodeType = element.nodeName.toUpperCase();\r\n\r\n    const canvas = (() => {\r\n      if (nodeType === 'CANVAS') {\r\n        return element as HTMLCanvasElement;\r\n      }\r\n      const canvas = document.createElement('canvas');\r\n      element.appendChild(canvas);\r\n      return canvas;\r\n    })();\r\n\r\n    canvas.setAttribute('width', width);\r\n    canvas.setAttribute('height', height);\r\n\r\n    return new RenderTarget(canvas);\r\n  }\r\n\r\n  getContext() {\r\n    return this.node.getContext('2d');\r\n  }\r\n}\r\n","import { RenderTargetInitFunction } from '../../typings/types';\r\nimport HanziWriterRenderer from './HanziWriterRenderer';\r\nimport RenderTarget from './RenderTarget';\r\n\r\nexport default {\r\n  HanziWriterRenderer,\r\n  createRenderTarget: RenderTarget.init as RenderTargetInitFunction<HTMLCanvasElement>,\r\n};\r\n","import Character from '../../models/Character';\r\nimport Positioner from '../../Positioner';\r\nimport HanziWriterRendererBase from '../HanziWriterRendererBase';\r\nimport CanvasRenderTarget from '../canvas/RenderTarget';\r\nimport CharacterRenderer from './CharacterRenderer';\r\nimport renderUserStroke from './renderUserStroke';\r\nimport { RenderStateObject } from '../../RenderState';\r\nimport { noop } from '../../utils';\r\n\r\nexport default class HanziWriterRenderer\r\n  implements HanziWriterRendererBase<HTMLCanvasElement, CanvasRenderTarget> {\r\n  _character: Character;\r\n  _positioner: Positioner;\r\n  _mainCharRenderer: CharacterRenderer;\r\n  _outlineCharRenderer: CharacterRenderer;\r\n  _highlightCharRenderer: CharacterRenderer;\r\n  _target: CanvasRenderTarget | undefined;\r\n\r\n  constructor(character: Character, positioner: Positioner) {\r\n    this._character = character;\r\n    this._positioner = positioner;\r\n    this._mainCharRenderer = new CharacterRenderer(character);\r\n    this._outlineCharRenderer = new CharacterRenderer(character);\r\n    this._highlightCharRenderer = new CharacterRenderer(character);\r\n  }\r\n\r\n  mount(target: CanvasRenderTarget) {\r\n    this._target = target;\r\n  }\r\n\r\n  destroy = noop;\r\n\r\n  _animationFrame(cb: (ctx: CanvasRenderingContext2D) => void) {\r\n    const { width, height, scale, xOffset, yOffset } = this._positioner;\r\n    const ctx = this._target!.getContext()!;\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.save();\r\n    ctx.translate(xOffset, height - yOffset);\r\n    ctx.transform(1, 0, 0, -1, 0, 0);\r\n    ctx.scale(scale, scale);\r\n    cb(ctx);\r\n    ctx.restore();\r\n    // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\r\n    if (ctx.draw) {\r\n      // @ts-expect-error\r\n      ctx.draw();\r\n    }\r\n  }\r\n\r\n  render(props: RenderStateObject) {\r\n    const { outline, main, highlight } = props.character;\r\n    const {\r\n      outlineColor,\r\n      strokeColor,\r\n      radicalColor,\r\n      highlightColor,\r\n      drawingColor,\r\n      drawingWidth,\r\n    } = props.options;\r\n\r\n    this._animationFrame((ctx) => {\r\n      this._outlineCharRenderer.render(ctx, {\r\n        opacity: outline.opacity,\r\n        strokes: outline.strokes,\r\n        strokeColor: outlineColor,\r\n      });\r\n      this._mainCharRenderer.render(ctx, {\r\n        opacity: main.opacity,\r\n        strokes: main.strokes,\r\n        strokeColor: strokeColor,\r\n        radicalColor: radicalColor,\r\n      });\r\n      this._highlightCharRenderer.render(ctx, {\r\n        opacity: highlight.opacity,\r\n        strokes: highlight.strokes,\r\n        strokeColor: highlightColor,\r\n      });\r\n\r\n      const userStrokes = props.userStrokes || {};\r\n\r\n      for (const userStrokeId in userStrokes) {\r\n        const userStroke = userStrokes[userStrokeId];\r\n        if (userStroke) {\r\n          const userStrokeProps = {\r\n            strokeWidth: drawingWidth,\r\n            strokeColor: drawingColor,\r\n            ...userStroke,\r\n          };\r\n          renderUserStroke(ctx, userStrokeProps);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { CharacterJson } from './typings/types';\r\n\r\nconst VERSION = '2.0';\r\nconst getCharDataUrl = (char: string) =>\r\n  `https://cdn.jsdelivr.net/npm/hanzi-writer-data@${VERSION}/${char}.json`;\r\n\r\nconst defaultCharDataLoader = (\r\n  char: string,\r\n  onLoad: (parsedJson: CharacterJson) => void,\r\n  onError: (error?: any, context?: any) => void,\r\n) => {\r\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\r\n  const xhr = new XMLHttpRequest();\r\n  if (xhr.overrideMimeType) {\r\n    // IE 9 and 10 don't seem to support this...\r\n    xhr.overrideMimeType('application/json');\r\n  }\r\n  xhr.open('GET', getCharDataUrl(char), true);\r\n  xhr.onerror = (event) => {\r\n    onError(xhr, event);\r\n  };\r\n  xhr.onreadystatechange = () => {\r\n    // TODO: error handling\r\n    if (xhr.readyState !== 4) return;\r\n\r\n    if (xhr.status === 200) {\r\n      onLoad(JSON.parse(xhr.responseText));\r\n    } else if (xhr.status !== 0 && onError) {\r\n      onError(xhr);\r\n    }\r\n  };\r\n  xhr.send(null);\r\n};\r\n\r\nexport default defaultCharDataLoader;\r\n","import { HanziWriterOptions } from './typings/types';\r\nimport defaultCharDataLoader from './defaultCharDataLoader';\r\n\r\nconst defaultOptions: HanziWriterOptions = {\r\n  charDataLoader: defaultCharDataLoader,\r\n  onLoadCharDataError: null,\r\n  onLoadCharDataSuccess: null,\r\n  showOutline: true,\r\n  showCharacter: true,\r\n  renderer: 'svg',\r\n\r\n  // positioning options\r\n\r\n  width: 0,\r\n  height: 0,\r\n  padding: 20,\r\n\r\n  // animation options\r\n\r\n  strokeAnimationSpeed: 1,\r\n  strokeFadeDuration: 400,\r\n  strokeHighlightDuration: 200,\r\n  strokeHighlightSpeed: 2,\r\n  delayBetweenStrokes: 1000,\r\n  delayBetweenLoops: 2000,\r\n\r\n  // colors\r\n\r\n  strokeColor: '#555',\r\n  radicalColor: null,\r\n  highlightColor: '#AAF',\r\n  outlineColor: '#DDD',\r\n  drawingColor: '#333',\r\n\r\n  // quiz options\r\n\r\n  leniency: 1,\r\n  showHintAfterMisses: 3,\r\n  highlightOnComplete: true,\r\n  highlightCompleteColor: null,\r\n  markStrokeCorrectAfterMisses: false,\r\n  acceptBackwardsStrokes: false,\r\n  quizStartStrokeNum: 0,\r\n  averageDistanceThreshold: 350,\r\n\r\n  // undocumented obscure options\r\n\r\n  drawingFadeDuration: 300,\r\n  drawingWidth: 4,\r\n  strokeWidth: 2,\r\n  outlineWidth: 2,\r\n  rendererOverride: {},\r\n};\r\n\r\nexport default defaultOptions;\r\n","import { CharacterJson, LoadingManagerOptions } from './typings/types';\r\n\r\ntype CustomError = Error & { reason: string };\r\n\r\nexport default class LoadingManager {\r\n  _loadCounter = 0;\r\n  _isLoading = false;\r\n  _resolve: ((data: CharacterJson) => void) | undefined;\r\n  _reject: ((error?: Error | CustomError | string) => void) | undefined;\r\n  _options: LoadingManagerOptions;\r\n\r\n  /** Set when calling LoadingManager.loadCharData  */\r\n  _loadingChar: string | undefined;\r\n  /** use this to attribute to determine if there was a problem with loading */\r\n  loadingFailed = false;\r\n\r\n  constructor(options: LoadingManagerOptions) {\r\n    this._options = options;\r\n  }\r\n\r\n  _debouncedLoad(char: string, count: number) {\r\n    // these wrappers ignore all responses except the most recent.\r\n    const wrappedResolve = (data: CharacterJson) => {\r\n      if (count === this._loadCounter) {\r\n        this._resolve?.(data);\r\n      }\r\n    };\r\n    const wrappedReject = (reason?: Error | string) => {\r\n      if (count === this._loadCounter) {\r\n        this._reject?.(reason);\r\n      }\r\n    };\r\n\r\n    const returnedData = this._options.charDataLoader(\r\n      char,\r\n      wrappedResolve,\r\n      wrappedReject,\r\n    );\r\n\r\n    if (returnedData) {\r\n      if ('then' in returnedData) {\r\n        returnedData.then(wrappedResolve).catch(wrappedReject);\r\n      } else {\r\n        wrappedResolve(returnedData);\r\n      }\r\n    }\r\n  }\r\n\r\n  _setupLoadingPromise() {\r\n    return new Promise(\r\n      (\r\n        resolve: (data: CharacterJson) => void,\r\n        reject: (err?: Error | CustomError | string) => void,\r\n      ) => {\r\n        this._resolve = resolve;\r\n        this._reject = reject;\r\n      },\r\n    )\r\n      .then((data: CharacterJson) => {\r\n        this._isLoading = false;\r\n        this._options.onLoadCharDataSuccess?.(data);\r\n        return data;\r\n      })\r\n      .catch((reason) => {\r\n        this._isLoading = false;\r\n        this.loadingFailed = true;\r\n\r\n        // If the user has provided an \"onLoadCharDataError\", call this function\r\n        // Otherwise, throw the promise\r\n        if (this._options.onLoadCharDataError) {\r\n          this._options.onLoadCharDataError(reason);\r\n          return;\r\n        }\r\n\r\n        // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\r\n        if (reason instanceof Error) {\r\n          throw reason;\r\n        }\r\n\r\n        const err = new Error(\r\n          `Failed to load char data for ${this._loadingChar}`,\r\n        ) as CustomError;\r\n\r\n        err.reason = reason;\r\n\r\n        throw err;\r\n      });\r\n  }\r\n\r\n  loadCharData(char: string) {\r\n    this._loadingChar = char;\r\n    const promise = this._setupLoadingPromise();\r\n    this.loadingFailed = false;\r\n    this._isLoading = true;\r\n    this._loadCounter++;\r\n    this._debouncedLoad(char, this._loadCounter);\r\n    return promise;\r\n  }\r\n}\r\n","import RenderState from './RenderState';\r\nimport parseCharData from './parseCharData';\r\nimport Positioner from './Positioner';\r\nimport Quiz from './Quiz';\r\nimport svgRenderer from './renderers/svg';\r\nimport canvasRenderer from './renderers/canvas';\r\nimport defaultOptions from './defaultOptions';\r\nimport LoadingManager from './LoadingManager';\r\nimport * as characterActions from './characterActions';\r\nimport { trim, colorStringToVals, selectIndex, fixIndex } from './utils';\r\nimport Character from './models/Character';\r\nimport HanziWriterRendererBase, {\r\n  HanziWriterRendererConstructor,\r\n} from './renderers/HanziWriterRendererBase';\r\nimport RenderTargetBase from './renderers/RenderTargetBase';\r\nimport { GenericMutation } from './Mutation';\r\n\r\n// Typings\r\nimport {\r\n  ColorOptions,\r\n  DimensionOptions,\r\n  HanziWriterOptions,\r\n  LoadingManagerOptions,\r\n  OnCompleteFunction,\r\n  ParsedHanziWriterOptions,\r\n  QuizOptions,\r\n  RenderTargetInitFunction,\r\n} from './typings/types';\r\n\r\n// Export type interfaces\r\nexport * from './typings/types';\r\n\r\nexport default class HanziWriter {\r\n  _options: ParsedHanziWriterOptions;\r\n  _loadingManager: LoadingManager;\r\n  /** Only set when calling .setCharacter() */\r\n  _char: string | undefined;\r\n  /** Only set when calling .setCharacter() */\r\n  _renderState: RenderState | undefined;\r\n  /** Only set when calling .setCharacter() */\r\n  _character: Character | undefined;\r\n  /** Only set when calling .setCharacter() */\r\n  _positioner: Positioner | undefined;\r\n  /** Only set when calling .setCharacter() */\r\n  _hanziWriterRenderer: HanziWriterRendererBase<HTMLElement, any> | null | undefined;\r\n  /** Only set when calling .setCharacter() */\r\n  _withDataPromise: Promise<void> | undefined;\r\n\r\n  _quiz: Quiz | undefined;\r\n  _renderer: {\r\n    HanziWriterRenderer: HanziWriterRendererConstructor;\r\n    createRenderTarget: RenderTargetInitFunction<any>;\r\n  };\r\n\r\n  target: RenderTargetBase;\r\n\r\n  /** Main entry point */\r\n  static create(\r\n    element: string | HTMLElement,\r\n    character: string,\r\n    options?: Partial<HanziWriterOptions>,\r\n  ) {\r\n    const writer = new HanziWriter(element, options);\r\n    writer.setCharacter(character);\r\n\r\n    return writer;\r\n  }\r\n\r\n  /** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\r\n  static _loadingManager: LoadingManager | null = null;\r\n  /** Singleton loading options. Only set in `loadCharacterData` */\r\n  static _loadingOptions: Partial<HanziWriterOptions> | null = null;\r\n\r\n  static loadCharacterData(\r\n    character: string,\r\n    options: Partial<LoadingManagerOptions> = {},\r\n  ) {\r\n    const loadingManager = (() => {\r\n      const { _loadingManager, _loadingOptions } = HanziWriter;\r\n      if (_loadingManager?._loadingChar === character && _loadingOptions === options) {\r\n        return _loadingManager;\r\n      }\r\n      return new LoadingManager({ ...defaultOptions, ...options });\r\n    })();\r\n\r\n    HanziWriter._loadingManager = loadingManager;\r\n    HanziWriter._loadingOptions = options;\r\n    return loadingManager.loadCharData(character);\r\n  }\r\n\r\n  static getScalingTransform(width: number, height: number, padding = 0) {\r\n    const positioner = new Positioner({ width, height, padding });\r\n    return {\r\n      x: positioner.xOffset,\r\n      y: positioner.yOffset,\r\n      scale: positioner.scale,\r\n      transform: trim(`\r\n        translate(${positioner.xOffset}, ${positioner.height - positioner.yOffset})\r\n        scale(${positioner.scale}, ${-1 * positioner.scale})\r\n      `).replace(/\\s+/g, ' '),\r\n    };\r\n  }\r\n\r\n  constructor(element: string | HTMLElement, options: Partial<HanziWriterOptions> = {}) {\r\n    const { HanziWriterRenderer, createRenderTarget } =\r\n      options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\r\n    const rendererOverride = options.rendererOverride || {};\r\n\r\n    this._renderer = {\r\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\r\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget,\r\n    };\r\n    // wechat miniprogram component needs direct access to the render target, so this is public\r\n    this.target = this._renderer.createRenderTarget(\r\n      element,\r\n      options.width,\r\n      options.height,\r\n    );\r\n    this._options = this._assignOptions(options);\r\n    this._loadingManager = new LoadingManager(this._options);\r\n    this._setupListeners();\r\n  }\r\n\r\n  showCharacter(\r\n    options: {\r\n      onComplete?: OnCompleteFunction;\r\n      duration?: number;\r\n    } = {},\r\n  ) {\r\n    this._options.showCharacter = true;\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.showCharacter(\r\n            'main',\r\n            this._character!,\r\n            typeof options.duration === 'number'\r\n              ? options.duration\r\n              : this._options.strokeFadeDuration,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  hideCharacter(\r\n    options: {\r\n      onComplete?: OnCompleteFunction;\r\n      duration?: number;\r\n    } = {},\r\n  ) {\r\n    this._options.showCharacter = false;\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.hideCharacter(\r\n            'main',\r\n            this._character!,\r\n            typeof options.duration === 'number'\r\n              ? options.duration\r\n              : this._options.strokeFadeDuration,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  animateCharacter(\r\n    options: {\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    this.cancelQuiz();\r\n\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.animateCharacter(\r\n            'main',\r\n            this._character!,\r\n            this._options.strokeFadeDuration,\r\n            this._options.strokeAnimationSpeed,\r\n            this._options.delayBetweenStrokes,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  animateStroke(\r\n    strokeNum: number,\r\n    options: {\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    this.cancelQuiz();\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.animateSingleStroke(\r\n            'main',\r\n            this._character!,\r\n            fixIndex(strokeNum, this._character!.strokes.length),\r\n            this._options.strokeAnimationSpeed,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  highlightStroke(\r\n    strokeNum: number,\r\n    options: {\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    const promise = () => {\r\n      if (!this._character || !this._renderState) {\r\n        return;\r\n      }\r\n\r\n      return this._renderState\r\n        .run(\r\n          characterActions.highlightStroke(\r\n            selectIndex(this._character.strokes, strokeNum),\r\n            colorStringToVals(this._options.highlightColor),\r\n            this._options.strokeHighlightSpeed,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        });\r\n    };\r\n\r\n    return this._withData(promise);\r\n  }\r\n\r\n  async loopCharacterAnimation() {\r\n    this.cancelQuiz();\r\n    return this._withData(() =>\r\n      this._renderState!.run(\r\n        characterActions.animateCharacterLoop(\r\n          'main',\r\n          this._character!,\r\n          this._options.strokeFadeDuration,\r\n          this._options.strokeAnimationSpeed,\r\n          this._options.delayBetweenStrokes,\r\n          this._options.delayBetweenLoops,\r\n        ),\r\n        { loop: true },\r\n      ),\r\n    );\r\n  }\r\n\r\n  pauseAnimation() {\r\n    return this._withData(() => this._renderState?.pauseAll());\r\n  }\r\n\r\n  resumeAnimation() {\r\n    return this._withData(() => this._renderState?.resumeAll());\r\n  }\r\n\r\n  showOutline(\r\n    options: {\r\n      duration?: number;\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    this._options.showOutline = true;\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.showCharacter(\r\n            'outline',\r\n            this._character!,\r\n            typeof options.duration === 'number'\r\n              ? options.duration\r\n              : this._options.strokeFadeDuration,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  hideOutline(\r\n    options: {\r\n      duration?: number;\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    this._options.showOutline = false;\r\n    return this._withData(() =>\r\n      this._renderState\r\n        ?.run(\r\n          characterActions.hideCharacter(\r\n            'outline',\r\n            this._character!,\r\n            typeof options.duration === 'number'\r\n              ? options.duration\r\n              : this._options.strokeFadeDuration,\r\n          ),\r\n        )\r\n        .then((res) => {\r\n          options.onComplete?.(res);\r\n          return res;\r\n        }),\r\n    );\r\n  }\r\n\r\n  /** Updates the size of the writer instance without resetting render state */\r\n  updateDimensions({ width, height, padding }: Partial<DimensionOptions>) {\r\n    if (width !== undefined) this._options.width = width;\r\n    if (height !== undefined) this._options.height = height;\r\n    if (padding !== undefined) this._options.padding = padding;\r\n    this.target.updateDimensions(this._options.width, this._options.height);\r\n    // if there's already a character drawn, destroy and recreate the renderer in the same state\r\n    if (\r\n      this._character &&\r\n      this._renderState &&\r\n      this._hanziWriterRenderer &&\r\n      this._positioner\r\n    ) {\r\n      this._hanziWriterRenderer.destroy();\r\n      const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character);\r\n      // TODO: this should probably implement EventEmitter instead of manually tracking updates like this\r\n      this._renderState.overwriteOnStateChange((nextState) =>\r\n        hanziWriterRenderer.render(nextState),\r\n      );\r\n      hanziWriterRenderer.render(this._renderState.state);\r\n      // update the current quiz as well, if one is active\r\n      if (this._quiz) {\r\n        this._quiz.setPositioner(this._positioner);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateColor(\r\n    colorName: keyof ColorOptions,\r\n    colorVal: string | null,\r\n    options: {\r\n      duration?: number;\r\n      onComplete?: OnCompleteFunction;\r\n    } = {},\r\n  ) {\r\n    let mutations: GenericMutation[] = [];\r\n\r\n    const fixedColorVal = (() => {\r\n      // If we're removing radical color, tween it to the stroke color\r\n      if (colorName === 'radicalColor' && !colorVal) {\r\n        return this._options.strokeColor;\r\n      }\r\n      return colorVal;\r\n    })();\r\n\r\n    const mappedColor = colorStringToVals(fixedColorVal as string);\r\n\r\n    this._options[colorName] = colorVal as any;\r\n\r\n    const duration = options.duration ?? this._options.strokeFadeDuration;\r\n\r\n    mutations = mutations.concat(\r\n      characterActions.updateColor(colorName, mappedColor, duration),\r\n    );\r\n\r\n    // make sure to set radicalColor back to null after the transition finishes if val == null\r\n    if (colorName === 'radicalColor' && !colorVal) {\r\n      mutations = mutations.concat(characterActions.updateColor(colorName, null, 0));\r\n    }\r\n\r\n    return this._withData(() =>\r\n      this._renderState?.run(mutations).then((res) => {\r\n        options.onComplete?.(res);\r\n        return res;\r\n      }),\r\n    );\r\n  }\r\n\r\n  quiz(quizOptions: Partial<QuizOptions> = {}) {\r\n    return this._withData(async () => {\r\n      if (this._character && this._renderState && this._positioner) {\r\n        this.cancelQuiz();\r\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\r\n        this._options = {\r\n          ...this._options,\r\n          ...quizOptions,\r\n        };\r\n        this._quiz.startQuiz(this._options);\r\n      }\r\n    });\r\n  }\r\n\r\n  skipQuizStroke() {\r\n    if (this._quiz) {\r\n      this._quiz.nextStroke();\r\n    }\r\n  }\r\n\r\n  cancelQuiz() {\r\n    if (this._quiz) {\r\n      this._quiz.cancel();\r\n      this._quiz = undefined;\r\n    }\r\n  }\r\n\r\n  setCharacter(char: string) {\r\n    this.cancelQuiz();\r\n    this._char = char;\r\n    if (this._hanziWriterRenderer) {\r\n      this._hanziWriterRenderer.destroy();\r\n    }\r\n    if (this._renderState) {\r\n      this._renderState.cancelAll();\r\n    }\r\n    this._hanziWriterRenderer = null;\r\n    this._withDataPromise = this._loadingManager\r\n      .loadCharData(char)\r\n      .then((pathStrings) => {\r\n        // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\r\n        if (!pathStrings || this._loadingManager.loadingFailed) {\r\n          return;\r\n        }\r\n\r\n        this._character = parseCharData(char, pathStrings);\r\n        this._renderState = new RenderState(this._character, this._options, (nextState) =>\r\n          hanziWriterRenderer.render(nextState),\r\n        );\r\n\r\n        const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(\r\n          this._character,\r\n        );\r\n        hanziWriterRenderer.render(this._renderState.state);\r\n      });\r\n    return this._withDataPromise;\r\n  }\r\n\r\n  _initAndMountHanziWriterRenderer(character: Character) {\r\n    const { width, height, padding } = this._options;\r\n    this._positioner = new Positioner({ width, height, padding });\r\n    const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(\r\n      character,\r\n      this._positioner,\r\n    );\r\n    hanziWriterRenderer.mount(this.target);\r\n    this._hanziWriterRenderer = hanziWriterRenderer;\r\n    return hanziWriterRenderer;\r\n  }\r\n\r\n  async getCharacterData(): Promise<Character> {\r\n    if (!this._char) {\r\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\r\n    }\r\n    const character = await this._withData(() => this._character);\r\n    return character!;\r\n  }\r\n\r\n  _assignOptions(options: Partial<HanziWriterOptions>): ParsedHanziWriterOptions {\r\n    const mergedOptions = {\r\n      ...defaultOptions,\r\n      ...options,\r\n    };\r\n\r\n    // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\r\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\r\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\r\n    }\r\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\r\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\r\n    }\r\n\r\n    if (!options.highlightCompleteColor) {\r\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\r\n    }\r\n\r\n    return this._fillWidthAndHeight(mergedOptions);\r\n  }\r\n\r\n  /** returns a new options object with width and height filled in if missing */\r\n  _fillWidthAndHeight(options: HanziWriterOptions): ParsedHanziWriterOptions {\r\n    const filledOpts = { ...options };\r\n    if (filledOpts.width && !filledOpts.height) {\r\n      filledOpts.height = filledOpts.width;\r\n    } else if (filledOpts.height && !filledOpts.width) {\r\n      filledOpts.width = filledOpts.height;\r\n    } else if (!filledOpts.width && !filledOpts.height) {\r\n      const { width, height } = this.target.getBoundingClientRect();\r\n      const minDim = Math.min(width, height);\r\n      filledOpts.width = minDim;\r\n      filledOpts.height = minDim;\r\n    }\r\n    return filledOpts as ParsedHanziWriterOptions;\r\n  }\r\n\r\n  _withData<T>(func: () => T) {\r\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\r\n    if (this._loadingManager.loadingFailed) {\r\n      throw Error('Failed to load character data. Call setCharacter and try again.');\r\n    }\r\n\r\n    if (this._withDataPromise) {\r\n      return this._withDataPromise.then(() => {\r\n        if (!this._loadingManager.loadingFailed) {\r\n          return func();\r\n        }\r\n      });\r\n    }\r\n    return Promise.resolve().then(func);\r\n  }\r\n\r\n  _setupListeners() {\r\n    this.target.addPointerStartListener((evt) => {\r\n      if (this._quiz) {\r\n        evt.preventDefault();\r\n        this._quiz.startUserStroke(evt.getPoint());\r\n      }\r\n    });\r\n    this.target.addPointerMoveListener((evt) => {\r\n      if (this._quiz) {\r\n        evt.preventDefault();\r\n        this._quiz.continueUserStroke(evt.getPoint());\r\n      }\r\n    });\r\n    this.target.addPointerEndListener(() => {\r\n      this._quiz?.endUserStroke();\r\n    });\r\n  }\r\n}\r\n"],"names":["globalObj","window","global","performanceNow","performance","now","Date","requestAnimationFrame","callback","setTimeout","cancelAnimationFrame","clearTimeout","arrLast","arr","length","fixIndex","index","copyAndMergeDeep","base","override","output","key","baseVal","overrideVal","Array","isArray","count","counter","average","reduce","acc","val","colorStringToVals","colorString","normalizedColor","toUpperCase","trim","test","hexParts","substring","split","hexStr","join","r","parseInt","slice","g","b","a","rgbMatch","match","parseFloat","Error","objRepeat","item","times","obj","i","objRepeatCb","cb","ua","navigator","userAgent","isMsBrowser","indexOf","noop","RenderState","constructor","character","options","onStateChange","_mutationChains","_onStateChange","state","drawingFadeDuration","drawingWidth","drawingColor","strokeColor","outlineColor","radicalColor","highlightColor","main","opacity","showCharacter","strokes","outline","showOutline","highlight","userStrokes","displayPortion","overwriteOnStateChange","updateState","stateChanges","nextState","this","run","mutations","scopes","map","mut","scope","cancelMutations","Promise","resolve","mutationChain","_isActive","_index","_resolve","_mutations","_loop","loop","_scopes","push","_run","filter","chain","canceled","then","_getActiveMutations","pauseAll","forEach","mutation","pause","resumeAll","resume","scopesToCancel","chainId","scopeToCancel","startsWith","_cancelMutationChain","cancelAll","cancel","subtract","p1","p2","x","y","magnitude","point","Math","sqrt","pow","distance","point1","point2","round","precision","multiplier","points","lastPoint","dist","_extendPointOnLine","vect","norm","normalizeCurve","curve","outlinedCurve","numPoints","segmentLen","outlinePoints","endPoint","remainingCurvePoints","remainingDist","outlinePointFound","nextPointDist","shift","nextPoint","outlineCurve","mean","translatedCurve","scale","maxLen","newCurve","prevPoint","segLen","numNewPoints","ceil","newSegLen","subdivideCurve","getPathString","close","start","remainingPoints","pathString","roundedPoint","extendStart","filteredPoints","numFilteredPoints","curVect","prevVect","pop","_filterParallelPoints","newStart","extendedPoints","unshift","Stroke","path","strokeNum","isInRadical","getStartingPoint","getEndingPoint","getLength","getVectors","vector","getDistance","distances","strokePoint","min","getAverageDistance","Character","symbol","generateStrokes","radStrokes","medians","pointData","from","to","preScaledWidth","preScaledHeight","Positioner","padding","width","height","effectiveWidth","effectiveHeight","scaleX","scaleY","xCenteringBuffer","yCenteringBuffer","xOffset","yOffset","convertExternalPoint","directionMatches","stroke","edgeVectors","vectors","getEdgeVectors","strokeVectors","edgeVector","strokeSimilarities","strokeVector","cosineSimilarity","max","stripDuplicates","firstPoint","rest","dedupedPoints","SHAPE_FIT_ROTATIONS","PI","shapeFit","curve1","curve2","leniency","normCurve1","normCurve2","minDist","Infinity","theta","longCurve","shortCurve","calcVal","j","prevResultsCol","curResultsCol","lastResult","frechetDist","cos","sin","rotate","getMatchData","isOutlineVisible","checkBackwards","averageDistanceThreshold","avgDist","withinDistThresh","isMatch","meta","isStrokeBackwards","startAndEndMatch","closestStroke","startingDist","endingDist","startAndEndMatches","directionMatch","shapeMatch","lengthMatch","lengthMatches","reverse","UserStroke","id","startingPoint","startingExternalPoint","externalPoints","appendPoint","externalPoint","Mutation","valuesOrCallable","_tick","timing","_startPauseTime","progress","_startTime","_pausedDuration","_duration","_renderState","_values","_frameHandle","undefined","easedProgress","ease","getPartialValues","_startState","_valuesOrCallable","duration","_force","force","renderState","_inflateValues","isAlreadyAtEnd","values","parts","final","current","cap","inflate","startValues","endValues","target","endValue","startValue","Delay","_paused","_runningPromise","_timeout","elapsedDelay","showStrokes","charName","hideCharacter","updateColor","colorName","colorVal","highlightStroke","color","speed","animateStroke","animateCharacter","fadeDuration","delayBetweenStrokes","concat","removeAllUserStrokes","userStrokeIds","userStrokeId","Quiz","positioner","_currentStrokeIndex","_mistakesOnStroke","_totalMistakes","_character","_positioner","startQuiz","_userStrokesIds","quizActions","_options","startIndex","quizStartStrokeNum","strokeFadeDuration","startStrokeNum","characterActions","startUserStroke","_userStroke","endUserStroke","strokeId","continueUserStroke","nextPoints","setPositioner","acceptBackwardsStrokes","markStrokeCorrectAfterMisses","currentStroke","_getCurrentStroke","userStroke","laterStrokes","closestMatchDist","leniencyAdjustment","strokeMatches","isForceAccepted","_handleSuccess","_handleFailure","showHintAfterMisses","strokeHighlightSpeed","_getStrokeData","isCorrect","mistakesOnStroke","totalMistakes","strokesRemaining","drawnPath","geometry","isBackwards","nextStroke","onComplete","highlightOnComplete","highlightCompleteColor","strokeHighlightDuration","animation","onCorrectStroke","onMistake","createElm","elmType","document","createElementNS","attr","elm","name","value","setAttributeNS","attrs","attrsMap","Object","keys","attrName","removeElm","parentNode","removeChild","StrokeRendererBase","_pathLength","STROKE_WIDTH","_getStrokeDashoffset","_getColor","StrokeRenderer","_oldProps","mount","_animationPath","svg","_clip","_strokePath","maskId","style","prefix","location","href","replace","extendedMaskPoints","toString","fill","appendChild","defs","render","props","_this$_oldProps","strokeDashoffset","_this$_oldProps2","CharacterRenderer","_strokeRenderers","subTarget","createSubRenderTarget","_group","strokeRenderer","display","removeProperty","colorsChanged","_this$_oldProps3","_this$_oldProps4","UserStrokeRenderer","_path","strokeWidth","destroy","RenderTargetBase","node","addPointerStartListener","addEventListener","evt","_eventify","_getMousePoint","_getTouchPoint","addPointerMoveListener","addPointerEndListener","getBoundingClientRect","updateDimensions","setAttribute","pointFunc","getPoint","call","preventDefault","left","top","clientX","clientY","touches","RenderTarget","_pt","createSVGPoint","elmOrId","element","getElementById","nodeType","nodeName","group","localPt","matrixTransform","getScreenCTM","_this$node$getScreenC","inverse","super","_this$node$getScreenC2","HanziWriterRenderer","_mainCharRenderer","_outlineCharRenderer","_highlightCharRenderer","_userStrokeRenderers","positionedTarget","_positionedTarget","userStrokeProps","newStrokeRenderer","innerHTML","createRenderTarget","init","drawPath","ctx","beginPath","moveTo","lineTo","usePath2D","Path2D","_path2D","_pathCmd","pathParts","part","commands","cmd","rawParams","params","param","bezierCurveTo","quadraticCurveTo","pathStringToCanvas","_extendedMaskPoints","save","clip","globalAlpha","dashOffset","strokeStyle","fillStyle","lineWidth","lineCap","lineJoin","setLineDash","lineDashOffset","restore","renderUserStroke","canvas","createElement","getContext","_target","_animationFrame","clearRect","translate","transform","draw","defaultOptions","charDataLoader","char","onLoad","onError","xhr","XMLHttpRequest","overrideMimeType","open","getCharDataUrl","onerror","event","onreadystatechange","readyState","status","JSON","parse","responseText","send","onLoadCharDataError","onLoadCharDataSuccess","renderer","strokeAnimationSpeed","delayBetweenLoops","outlineWidth","rendererOverride","LoadingManager","_loadCounter","_isLoading","loadingFailed","_debouncedLoad","wrappedResolve","data","wrappedReject","reason","_reject","returnedData","catch","_setupLoadingPromise","reject","err","_loadingChar","loadCharData","promise","HanziWriter","canvasRenderer","svgRenderer","_renderer","_assignOptions","_loadingManager","_setupListeners","writer","setCharacter","loadingManager","_loadingOptions","string","_withData","_this$_renderState","res","_this$_renderState2","cancelQuiz","_this$_renderState3","_this$_renderState4","curCharState","mutationState","pauseAnimation","_this$_renderState5","resumeAnimation","_this$_renderState6","_this$_renderState7","hideOutline","_this$_renderState8","_hanziWriterRenderer","hanziWriterRenderer","_initAndMountHanziWriterRenderer","_quiz","mappedColor","_this$_renderState9","quiz","quizOptions","async","skipQuizStroke","_char","_withDataPromise","pathStrings","charJson","parseCharData","mergedOptions","strokeAnimationDuration","_fillWidthAndHeight","filledOpts","minDim","func"],"mappings":"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"}